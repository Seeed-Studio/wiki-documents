---
name: Eagleye 530s
category: Artik
bzurl: https://www.seeedstudio.com/Eagleye-530s-p-3035.html
oldwikiname:
prodimagename:
surveyurl:
sku: 114991433
---

![enter image description here](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/eagleye_530s.JPG)


Seeed is an experienced designer of development kits for IoT technology platforms. Our latest development kit—the Eagleye 530s,--is designed to help you get started developing products and services for the [Samsung ARTIK™ IoT platform](https://www.artik.io/).
 
The Eagleye 530s is a high-performance, pre-tested, cost-effective and production-ready development kit which incorporates the Samsung ARTIK™ 530s--a 1GB system-on-module (SoM)-- on a custom credit card size board. For more information about ARTIK™ 530s, please click here.
 
What is Samsung ARTIK™? Samsung ARTIK™ is a pre-integrated IoT platform consisting of enterprise-grade system-on-modules (SoMs), cloud services, and end-to-end security for the design and development of robust IoT solutions. Developers frequently downplay the importance of security when designing and building IoT products. ARTIK integrated security services for SoMs and cloud make it easier for you to make your products secure.  
 
As mentioned above, the Eagleye530s is based on the ARTIK 530s 1GB SoM, which is a Quad Core Cortex® A9 running @ 1.2 GHz with 4 B Flash memory, hardware-based security features, and Linux OS (Ubuntu). The Eagleye 530s also provides a 40 pin GPIO and accessory interface for Micro SD, Ethernet 10/100/1000, Wi-Fi 802.11 a/b/g/n, Bluetooth BLE 4.2 802.15.4, and ZigBee/Thread. It also supports full HDMI, MIPI camera interfaces, video, and audio media.
 
Since the Eagleye 530s is pin-compatible with many “maker” hardware accessories, it allows Samsung ARTIK™ developers to easily tap into the extensive “maker” accessories marketplace and prototype and build with off-the-shelf sensors (eg. [GrovePi+](https://www.seeedstudio.com/GrovePi%2B-p-2241.html),[Grove sensors](https://www.seeedstudio.com/grove.html)), voice recognition (eg. [ReSpeaker 2-mic array](https://www.seeedstudio.com/ReSpeaker-2-Mics-Pi-HAT-p-2874.html) and [ReSpeaker 4-mic array](https://www.seeedstudio.com/ReSpeaker-4-Mic-Array-for-Raspberry-Pi-p-2941.html)), relays, GPS, cellular connectivity, and more, providing many options for enterprise developers creating feature-rich proof-of-concepts (PoC) or production-ready products.

<iframe width="800" height="450" src="https://www.youtube.com/embed/4IR768d8Ins" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p style=":center"><a href="https://www.seeedstudio.com/Eagleye-530s-p-3035.html" target="_blank"><img src="https://raw.githubusercontent.com/SeeedDocument/Seeed-WiKi/master/docs/images/get_one_now_small.png" width="200" height="38"  border=0 /></a></p>


## Version

| Product Version     | Changes | Released Date |
|---------------------|---------|---------------|
| Eagleye 530s Rev1.0 | Initial | Feb 28 2018   |

## Features

- Powered by the Samsung ARTIK™ IoT platform.
- Incorporates ARTIK 530s 1GB SoM, a Quad Core Cortex® A9 running @ 1.2 GHz.
- Includes 40 pin GPIO and accessory interface.
- Support for Micro SD, Ethernet 10/100/1000, Wi-Fi 802.11 a/b/g/n, Bluetooth BLE 4.2 802.15.4, and ZigBee/Thread.
- Supports full HDMI, MIPI camera interface, video, and audio media.

## Specification

| Parameter        |                        | Value/Range                                                               |
|------------------|------------------------|---------------------------------------------------------------------------|
| Processor        |                        |                                                                           |
|                  | CPU                    | Quad core ARM® Cortex®-A9@1.2GHz                                          |
|                  | GPU                    | 3D graphics accelerator                                                   |
| Media            |                        |                                                                           |
|                  | Camera I/F             | 4-lane MIPI CSI up to 5M (1920x1080@30fps)                                |
|                  | Display                | 4-lane MIPI DSI and HDMI1.4a (1920x1080p@60fps) or LVDS (1280x720p@60fps) |
|                  | Audio                  | Two I2S audio input/output                                                |
| Memory           |                        |                                                                           |
|                  | DRAM                   | 512MB/1GB DDR3                                                            |
|                  | FLASH                  | 4GB eMMC v4.5                                                             |
| Security         |                        |                                                                           |
|                  | Secure Element         | Secure point to point authentication and data transfer                    |
| Radio            |                        |                                                                           |
|                  | WLAN                   | IEEE 802.11a/b/g/n, dual band SISO                                        |
|                  | Bluetooth®             | 4.2 (BLE+Classic)                                                         |
|                  | 802.15.4               | ZigBee®/Thread                                                            |
| Power Management |                        |                                                                           |
|                  | PMIC                   | Provides all power of the ARTIK 530 Module using on board bucks and LDO’s |
| Interfaces       |                        |                                                                           |
|                  | Ethernet               | 10/100/1000Base-T MAC (External PHY required)                             |
|                  | Analog and Digital I/O | GPIO, UART, I2C, SPI, USB Host, USB OTG, HSIC, ADC, PWM, I2S, JTAG        |

## Hardware Overview

**Block Diagram**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/block_digram.png)

**Interfaces**

Below figures show the overall preview of the Eagleye 530s' TOP and BOTTOM.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/eagleye_530s_front.JPG)

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/eagleye_530s_back.JPG)

- <font face="" size=5 font color="ff0000">ⓐ</font> **DC Power:** 5V DC power supply.

- <font face="" size=5 font color="ff0000">ⓑ</font> **USB Host 2.0 Interface:** has two USB 2.0 Interface.

- <font face="" size=5 font color="ff0000">ⓒ</font> **Ethernet:** The Ethernet Interface is based on 802.3az-2010 complying to the Energy Efficient Ethernet (EEE) standard. The maximum theoretical speed of the interface is 1000Mbps.

- <font face="" size=5 font color="ff0000">ⓓ</font> **Ear Jack:** has one 4 pin ear jack interface supporting stereo audio

- <font face="" size=5 font color="ff0000">ⓔ</font> **Boot Switch:** When ‘eMMc 1st Boot’ is selected as a booting option, the system will first try to boot from eMMc, if this fails the system will search for an SD Card to boot from. If booting from the SD-Card also fails the system tries to boot from USB. When choosing the SD-Card booting option, the system starts with booting from SD, and if this fails will continue to try a USB boot. When USB is selected as the booting mechanism of choice, only a USB boot will be attempted.

| SW402 | eMMc 1st Boot | SD Card 1st Boot | USB 1st Boot |
|-------|---------------|------------------|--------------|
| 1     | Off           | Off              | On           |
| 2     | Off           | Off              | On           |
| 3     | X             | X                | X            |
| 4     | Off           | On               | X            |

- <font face="" size=5 font color="ff0000">ⓕ</font> **HDMI:** has one HDMI 1.4a connector. The following video formats are supported:
    - 480p/480i @59.94Hz/60Hz, 576p/576i@50Hz
    - 720p/720i @50Hz/59.94Hz/60Hz
    - 1080p/1080i @50Hz/59.94Hz/60Hz

- <font face="" size=5 font color="ff0000">ⓖ</font> **USB OTG:** has one USB OTG.

- <font face="" size=5 font color="ff0000">ⓗ</font> **USB UART:** has one USB UART.

- <font face="" size=5 font color="ff0000">ⓘ</font> **User Button S4:**  switch named as S4, mapped to GPIO 54.

- <font face="" size=5 font color="ff0000">ⓚ</font> **Power On LED:** Led will be turned on when board power on.

- <font face="" size=5 font color="ff0000">ⓛ</font> **Power in LED:** Led will be turned on when board get power supply in.

- <font face="" size=5 font color="ff0000">ⓜ</font> **SD Card in LED:** Led will be turned on when SD is pluged into board.

- <font face="" size=5 font color="ff0000">ⓝ</font> **User Button S3:** switch named as S3, mapped to GPIO 50.

- <font face="" size=5 font color="ff0000">ⓞ</font> **MIPI CSI:** The MIPI CSI interface can have a static resolution of 5M pixels or a dynamic resolution for video capturing of 1080P.

- <font face="" size=5 font color="ff0000">ⓟ</font> **ANT(802.11):** If 802.11 or Bluetooth® functionality is required, the antenna which is enclosed as part of the Eagleye 530s has to be attached.

- <font face="" size=5 font color="ff0000">ⓠ</font> **Reset:** board resest.

- <font face="" size=5 font color="ff0000">ⓡ</font> **Power:** Once the power switch is turned on, push the power button (S1), for about 1 second.

- <font face="" size=5 font color="ff0000">ⓢ</font> **ANT(802.11):** If 802.11 or Bluetooth® functionality is required, the antenna which is enclosed as part of the Eagleye 530s has to be attached.

- <font face="" size=5 font color="ff0000">ⓣ</font> **User Pins:**  To make them versatile control and monitoring devices, Eagleye 530s provides many programmable signal pins. These pins directly handle tasks like controlling relays, generating analog voltages, and monitoring analog sensors, as well as complex tasks involving parallel and serial communication with more sophisticated control and sensor devices.

- <font face="" size=5 font color="ff0000">ⓤ</font> **ANT(Zigbee):** If Zigbee functionality is required, the antenna which is enclosed as part of the Eagleye 530s has to be attached.

- <font face="" size=5 font color="ff0000">ⓥ</font> **Power Switch:** Through selection of the Jumpers JP1and JP2, the power source can be selected. When power is provided from a DC-5V Adapter ,  jumpers JP2 will be placed and 3-4 position will be connected.
When the jumpers JP1 are in the 1-2 position, the power is provided from the usb-uart. When the Eagleye 530s is used with an external power adapter make certain that you use a 5V-2.5A adapter with a 2.1x5.5mm plug.

!!!warning
    NEVER connect both at the same time!

- <font face="" size=5 font color="ff0000">ⓦ</font> **SD card slot:** has one SD-CARD interface supporting SD3.0.  

- <font face="" size=5 font color="ff0000">ⓧ</font> **JTAG:** has one JTAG interface.

**Mechanical Drawing**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/MECHANICAL1.png)
![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/MECHANICAL2.png)
![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/MECHANICAL5.png)
![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/MECHANICAL4.png)

!!!note
    Mechanical Drawing all dimensions are in [mm].

## Application Ideas

* DIY
* IoT and Smart Home
* Robot

## Getting Started

**Unboxing Demo**

This section will describe how to start working with your Eagleye 530s Development Environment by setting up a serial connection on your development PC and booting up the Eagleye 530s Development Environment.

**Hardware**

- Step 1. Set the power switch(named as number 21 on hardware overview) to USB.
- Step 2. Connect USB cable from PC to USB UART(named as number 8 on hardware overview).
- Step 3. Press the Power button for more than 1 second and we will see the Green/Red LEDs(refer to Number 10/11 on hardware overview) are turned on.

  ![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/usb_connection.jpg)

**Software**

Setting up a connection with the Eagleye 530s Module can be done in a wired or wireless manner. Here we choose to install PuTTY a free serial console. The software can be downloaded from http://www.putty.org/. Once downloaded go through the following steps:

- Step 1. Open the device manager on the control panel.
- Step 2. When using a PC install the USB to Serial driver. The driver can be found at the following location: (http://www.ftdichip.com/Drivers/CDM/CDM21218_Setup.zip). For other drivers please visit (http://www.ftdichip.com/Drivers/D2XX.htm).
- Step 3. Check the COM port number on your PC when you connect the USB serial cable. In our case the COM port allocated is COM9.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Com.png)

- Step 4. Set the PuTTY configuration as follows:
    - Set the “Serial line” as the COM port number found in step 3.
    - Set the COM speed to "115200".
    - Set the connection type to "Serial".
    - Save the session under Eagleye 530s.
- Step 5. Select your saved session and click the “Open” button.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Putty_setup.png)

- Step 6. The username and password are root.
- Step 7. We will see the terminal as below.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Putty_normal_boot.png)

**Play with onboard LEDs**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/leds_buttons.jpg)

- Step 1. Download [blink_led.py](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/blink_led.py) or copy below code and paste to blink_led.py.

```python
#!/usr/bin/python

import time
import sys

print "Blink an LED"
ledpin = 159 # Blink the blue led, please change to 43 for red led

#export GPIO pin by opening file and writing the pin number to it
pinctl = open("/sys/class/gpio/export", "wb", 0)
try:
    pinctl.write( str(ledpin))
    print "Exported pin", str(ledpin)
except:
    print "Pin ", str(ledpin), " has been exported"
pinctl.close()

#set GPIO pin to be digital output
filename = '/sys/class/gpio/gpio%d/direction' % ledpin
pinctldir = open(filename, "wb", 0)
try:
    pinctldir.write("out")
    print "Set pin ", str(ledpin), " as digital output"
except:
    print "Failed to set pin direction"
pinctldir.close()

#unexport GPIO pin when we are done
def exit_gpio():
    pinctl = open("/sys/class/gpio/unexport", "wb", 0)
    try:
        pinctl.write( str(ledpin))
        print "Unexported pin", str(ledpin)
    except:
        print "Pin ", str(ledpin), " has been unexported"
    pinctl.close()

#change GPIO pin value every 10 seconds
filename = '/sys/class/gpio/gpio%d/value' % ledpin
while True:
    try:
        pin = open(filename, "wb", 0)
        pin.write( str(1) )
        time.sleep(1)

        pin.write( str(0) )
        time.sleep(1)
        pin.close()
    except:
        exit_gpio()
        sys.exit(0)
```

- Step 2. Run 'python blink_led.py'
- Step 3. We will see the led blink.

**Play with onboard Buttons**

- Step 1. Download [read_button.py](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/read_button.py) or copy below code to read_button.py.

```python
#!/usr/bin/python

import time
import sys

print "Toggle a button"
buttonpin = 54 # Read S4 button, please change to 50 for S3 button

#export pin 8 by opening file and writing the pin number to it
pinctl = open("/sys/class/gpio/export", "wb", 0)
try:
    pinctl.write( str(buttonpin))
    print "Exported pin", str(buttonpin)
except:
    print "Pin ", str(buttonpin), " has been exported"
pinctl.close()

#set pin to be digital input
filename = '/sys/class/gpio/gpio%d/direction' % buttonpin
pinctldir = open(filename, "wb", 0)
try:
    pinctldir.write("in")
    print "Set pin ", str(buttonpin), " as digital input"
except:
    print "Failed to set pin direction"
pinctldir.close()

def exit_gpio():
    #unexport pin
    pinctl = open("/sys/class/gpio/unexport", "wb", 0)
    try:
        pinctl.write( str(buttonpin))
        print "Unexported pin", str(buttonpin)
    except:
        print "Pin ", str(buttonpin), " has been unexported"
    pinctl.close()

#pin value changes when the button is pressed
filename = '/sys/class/gpio/gpio%d/value' % buttonpin
while True:
    try:
        pin = open(filename, "rb", 0)
        print pin.read()
        time.sleep(1)
        pin.close()
    except KeyboardInterrupt:
        exit_gpio()
        sys.exit(0)
```

- Step 2. Run 'python read_button.py'
- Step 3. We will see the terminal info as below.

```
[root@artik ~]# python read_button.py
Toggle a button
Pin  54  has been exported
Set pin  54  as digital input
1
1
0
0
```

**Ethernet and Wi-Fi Networks**

The below instructions discuss setting up a wired or wireless local area network (LAN). The Ethernet LAN (hard-wired) port is always available. A wireless LAN (WLAN) circuit is separately available, and can be configured by Connection Manager.

- Step 1. Scan for wireless access points. Enter commands as follows.
connmanctl to get the > prompt.
- Step 2. scan wifi to scan for available access points (wait until finished).
- Step 3. services to list them.
- Step 4. Select an access point. Still within the > prompt, enter commands as follows.
- Step 5. agent on if you want Connection Manager to prompt you for a password.
- Step 6. connect wifi_xxxx to pick the desired access point (you can use the tab key to start, and to auto-complete, your entry).
- Step 7. Respond to the agent query for a password if needed.
- Step 8. quit when finished.
- Step 9. We won't need to repeat this process in the future: Connection happens automatically from now on.

Here is the terminal information.

```
[root@artik ~]# connmanctl
Error getting VPN connections: The name net.connman.vpn was not provided by any connmanctl> scan wifi
Scan completed for wifi
connmanctl> scan wifi
connmanctl> services
*AO Wired                ethernet_000000000000_cable
    seeed                wifi_722c1f37ca11_XXXXXXXX_managed_psk
    ReSpeaker1DD346      wifi_722c1f37ca11_XXXXXXXX_managed_none
connmanctl> agent on
Agent registered
connmanctl> connect wifi_722c1f37ca11_XXXXXXXX_managed_psk
Agent RequestInput wifi_722c1f37ca11_XXXXXXXX_managed_psk
  Passphrase = [ Type=psk, Requirement=mandatory ]
Passphrase? 2018seeed
connmanctl> quit
[root@artik ~]#
```

**Firmware Update**

- Step 1. Download the [firmware](https://developer.artik.io/documentation/downloads.html#firmware), the files for the “ARTIK 530s 1G”.
- Step 2. Use [Etcher](https://etcher.io/) tool to burn the firmware to SD card.
- Step 3. Plug the SD card to Eagleye 530s SD slot.
- Step 4. Change boot switch(named as number 21 on hardware overview) Pin4 to on.
- Step 5. Connect the USB cable from PC to USB UART(named as number 8 on hardware overview).
- Step 6. Press the Power button for more than 1 second and we will see the Green/Red/Blue LEDs(refer to Number 10/11/12 on hardware overview) are turned on.
- Step 7. We will see below message and the firmware is downloaded successfuly.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Putty_firmware.png)

- Step 8. Please shutdown the board, remove SD card and switch boot switch Pin4 back to off.


## Play with Pin Programming

Eagleye boards provide many programmable signal pins. Some of these are General-Purpose Input/Output (GPIO) pins, while others are fixed-purpose pins for analog input, pulse-width-modulated output, and serialized communication.

- Digital Input (GPIO) – sensing a DC signal level at low (GND) or high (Vcc)
- Digital Output (GPIO) – driving a DC level (GND or Vcc) that can be controlled dynamically
- Waveform Output (PWM) – switching DC levels by a Pulse Width Modulation circuit with frequency and duty cycle that can be programmed dynamically.
- Serial Ports (I2C and UART) – sending and receiving data according to industry-standard protocols.
- Analog Input (ADC) – reading a varying signal level and processing through an analog-to-digital converter

 The sysfs functionality of the Linux kernel provides libraries to control and monitor programmable pins. Details are available at the [reference](https://www.kernel.org/doc/Documentation/gpio/sysfs.txt). 

Here is pinout of the connectors with its meaning.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/pin_map.png)


| Description | Pin Name   | Pin Number | Pin Number | Pin Name  | Description |
|-------------|------------|------------|------------|-----------|-------------|
| 3.3V        | 3.3V       | 1          | 2          | 5V        | 5V          |
| I2C         | XI2C0_SDA  | 3          | 4          | 5V        | 5V          |
| I2C         | XI2C0_SCL  | 5          | 6          | GND       | GND         |
| GPIO_161     | XAGPIO0    | 7          | 8          | XUART0_TX | UART        |
| GND         | GND        | 9          | 10         | XUART0_RX | UART        |
| GPIO_128    | XGPIO0     | 11         | 12         | I2SBCK1   | I2S         |
| GPIO_129    | XGPIO1     | 13         | 14         | GND       | GND         |
| PWM         | PWM2       | 15         | 16         | XGPIO2    | GPIO_130    |
| 3.3V        | 3.3V       | 17         | 18         | XGPIO3    | GPIO_46     |
| SPI         | XSPIO_MOSI | 19         | 20         | GND       | GND         |
| SPI         | XSPIO_MISO | 21         | 22         | PWM0      | PWM         |
| SPI         | XSPIO_CLK  | 23         | 24         | XSPIO0_CS | SPI         |
| GND         | GND        | 25         | 26         | XGPIO4    | GPIO_14     |
| NC          | NC         | 27         | 28         | NC        | NC          |
| GPIO_27     | XGPIO9     | 29         | 30         | GND       | GND         |
| GPIO_25     | XGPIO6     | 31         | 32         | XGPIO7    | GPIO_0      |
| GPIO_26     | XGPIO8     | 33         | 34         | GND       | GND         |
| I2S         | I2SLRCLK1  | 35         | 36         | XADC0     | ADC         |
| ADC         | XADC1      | 37         | 38         | I2SDIN1   | I2S         |
| GND         | GND        | 39         | 40         | I2SDOUT1  | I2S         |




**GPIO Control through Sysfs**

For example, pin 11 is GPIO and can be used as digital input or output. To use a particular GPIO, we would first set its direction (mode) as either input or output, and then read from or write to it as needed.

The [Play with onboard LEDs](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/blink_led.py) and [Play with onboard buttons](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/read_button.py)  tutorials provided examples of the necessary programming for digital I/O pins.

!!!warning
    Please change the specific GPIO pin number in the led/button python program.

**PWM Control through Sysfs**

For example, pin 22 is PWM. We can connect PWM of LED to PWM of 40 Pins and GND as well. We can set period and duty_cycle（Maximum limit  is 1,000,000,000 (expressed in ns).) Duty_cycle should always be less than period.

The following exercise demonstrates use of a PWM pin, setting a fixed blink rate. 

- Step 1. Export PWM0

    ```
    echo 0 > /sys/class/pwm/pwmchip0/export
    ```

A pwm0 subdirectory is created. (We can use echo 0 to create pwm0, echo 2 to create pwm2.)

- Step 2. Set attributes

    - a)	Set period (Unit: ns) to 1 sec

    ```
    echo 1000000000 > /sys/class/pwm/pwmchip0/pwm0/period
    ```

    - b)	Set duty_cycle (Unit: ns) to 500 msec

    ```
    echo 500000000 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle
    ```
    
    - c)	Enable PWM0

    ```
    echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable
    ```   

    - d)	Disable PWM0

    ```
    echo 0 > /sys/class/pwm/pwmchip0/pwm0/enable
    ```

- Step 3. Unexport PWM0

    ```
    echo 0 > /sys/class/pwm/pwmchip0/unexport
    ```

Here is the terminal information for pwm0. 

```
[root@artik pwmchip0]# echo 0 > /sys/class/pwm/pwmchip0/export    # please change to echo 2 for pwm2
[root@artik pwmchip0]# echo 1000000000 > /sys/class/pwm/pwmchip0/pwm0/period # please change to pwm2 from pwm0 for pwm2
[root@artik pwmchip0]# echo 500000000 > /sys/class/pwm/pwmchip0/pwm0/duty_cycle # please change to pwm2 from pwm0 for pwm2
[root@artik pwmchip0]# echo 1 > /sys/class/pwm/pwmchip0/pwm0/enable  # please change to pwm2 from pwm0 for pwm2
[root@artik pwmchip0]# echo 0 > /sys/class/pwm/pwmchip0/pwm0/enable # please change to pwm2 from pwm0 for pwm2
```

**ADC Control through Sysfs**

For example, pin 36 is ADC0. The following command line examples demonstrate how to read the current value of ADC0.

```
[root@artik dev]# cat /sys/devices/platform/c0000000.soc/c0053000.adc/iio:device0/in_voltage0_raw
0
[root@artik dev]# cat /sys/devices/platform/c0000000.soc/c0053000.adc/iio:device0/in_voltage0_raw
1211
[root@artik dev]# cat /sys/devices/platform/c0000000.soc/c0053000.adc/iio:device0/in_voltage0_raw
2027
[root@artik dev]# cat /sys/devices/platform/c0000000.soc/c0053000.adc/iio:device0/in_voltage0_raw
3017
[root@artik dev]# cat /sys/devices/platform/c0000000.soc/c0053000.adc/iio:device0/in_voltage0_raw
4095
```

!!!note
    Please change the in_voltage0_raw to in_voltage1_raw if we use pin37 (ADC1). 


**UART Control**

- Step 1. Run below command to enable UART0, and we can see ttyAMA4 in list, tested with [ARTIK 530s 1G Secure Module Firmware (Ubuntu): A533s_os_18.05.00](https://developer.artik.io/downloads/2768bd32-383a-44cf-9e90-9292712a96ba/download).


```
cd /sys/kernel/config/device-tree/overlays/
mkdir ttyAMA4
cd /boot/overlays
cat s5p4418-artik533-compy-serial4.dtbo  > /sys/kernel/config/device-tree/overlays/ttyAMA4/dtbo
cd /dev
ls tty*
```

- Step 2. Connect the UART0 TX/RX to USB2Serial adaptor.

| Pin Number | Pin Name   | USB2Serial Adaptor |
|------------|------------|--------------------|
| 6          | GND        | GND                |
| 8          | XUART0_TX  | RX                 |
| 10         | XUART0_RX  | TX                 |

- Step 3. Send "hello" to UART0

```
stty -F /dev/ttyAMA4 
echo “hello ..” > /dev/ttyAMA4
```

- Step 4. We can see the serial monitor as below.

```
hello ..
hello ..
hello ..
```

## Play with ReSpeakers Mics

**Play with 2 Mics Pi HAT**

**Hardware**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/2_Mics.jpg)

**Install 2 Mics Driver**

- Step 1. Download the Seeed-Voicecard driver.

```
[root@artik ~]# apt update
[root@artik ~]# apt install git
[root@artik ~]# git clone https://github.com/respeaker/seeed-voicecard
[root@artik ~]# cd seeed-voicecard
[root@artik seeed-voicecard]# git checkout remotes/origin/artikpi -b artiki
```

- Step 2. Install Seeed-Voicecard driver.

```
[root@artik ~]# cd seeed-voicecard/
[root@artik seeed-voicecard]# mount -o remount,rw /lib/modules
[root@artik seeed-voicecard]# sudo mkdir -p /lib/modules/4.4.113-0533GS0F-44U-01Q5/kernel/sound/soc/codecs/
[root@artik seeed-voicecard]# sudo cp snd-soc-ac108.ko.0533GS0F-44U-01Q5 /lib/modules/4.4.113-0533GS0F-44U-01Q5/kernel/sound/soc/codecs/snd-soc-ac108.ko
[root@artik seeed-voicecard]# sudo cp snd-soc-wm8960.ko.0533GS0F-44U-01Q5 /lib/modules/4.4.113-0533GS0F-44U-01Q5/kernel/sound/soc/codecs/snd-soc-wm8960.ko
[root@artik seeed-voicecard]# sudo depmod -a
```

- Step 3. Enable 2 Mics.

```
[root@artik ~]# cd seeed-voicecard
[root@artik seeed-voicecard]# su root
[root@artik seeed-voicecard]# mkdir /sys/kernel/config/device-tree/overlays/seeed-voicecard
[root@artik seeed-voicecard]# cat seeed-2mic-voicecard-artik.dtbo > /sys/kernel/config/device-tree/overlays/seeed-voicecard/dtbo
[root@artik seeed-voicecard]# cp wm8960_asound.state /var/lib/alsa/asound.state
[root@artik seeed-voicecard]# alsactl --file=wm8960_asound.state restore
```

!!!warning
    Please run Step 3 again after the rebooting, or else it can't detect the seeed voicecard.

- Step 4. Use the arecord to list the record devices.

```
[root@artik seeed-voicecard]# arecord -L
null
    Discard all samples (playback) or generate zero samples (capture)
pulse
    PulseAudio Sound Server
default
    Playback/recording through the PulseAudio sound server
playback
dmixed
ac108
sysdefault:CARD=Audio
    Artik530 raptor Audio,
    Default Audio Device
dmix:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Direct sample mixing device
dsnoop:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Direct sample snooping device
hw:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Direct hardware device without any conversions
plughw:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Hardware device with all software conversions
sysdefault:CARD=seeed2micvoicec
    seeed-2mic-voicecard,
    Default Audio Device
dmix:CARD=seeed2micvoicec,DEV=0
    seeed-2mic-voicecard,
    Direct sample mixing device
dsnoop:CARD=seeed2micvoicec,DEV=0
    seeed-2mic-voicecard,
    Direct sample snooping device
hw:CARD=seeed2micvoicec,DEV=0
    seeed-2mic-voicecard,
    Direct hardware device without any conversions
plughw:CARD=seeed2micvoicec,DEV=0
    seeed-2mic-voicecard,
    Hardware device with all software conversions
```

**Capture/Playback Audio**

- Start recording using the Command Line

```
arecord -f cd -Dplughw:1,0 /tmp/test.wav
aplay -Dplughw:1,0 /tmp/test.wav
```

Here is the hardware setup. We can hear the playback from the 2 Mics audio jack.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/2_Mics_Playback.jpg)

- Start recording using Python

    - Step 1. Install pyaudio package by below commands

      ```
      apt install python-pyaudio
      ```

    - Step 2. Use a text editor like vi to create this [recorder_2Mics.py](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/recorder_2Mics.py) code file, which records a 10-sec audio clip called test.wav.

```python
import pyaudio
import wave

FORMAT = pyaudio.paInt16
CHANNELS = 2
RATE = 48000
CHUNK = 1024
RECORD_SECONDS = 10
WAVE_OUTPUT_FILENAME = "test.wav"

audio = pyaudio.PyAudio()

# start Recording
stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)
print "recording audio..."
frames = []

threshold = 800
for i in range(0, int(RATE / CHUNK * RECORD_SECONDS)):
   data = stream.read(CHUNK)
   frames.append(data)
print "done recording"

# stop Recording
stream.stop_stream()
stream.close()
audio.terminate()

waveFile = wave.open(WAVE_OUTPUT_FILENAME, 'wb')
waveFile.setnchannels(CHANNELS)
waveFile.setsampwidth(audio.get_sample_size(FORMAT))
waveFile.setframerate(RATE)
waveFile.writeframes(b''.join(frames))
waveFile.close()
```

!!!warning
    For more information, such as play with google assistant, please refer to [ReSpeaker 2-Mics Pi HAT](http://wiki.seeedstudio.com/ReSpeaker_2_Mics_Pi_HAT/).

**Play with 4 Mics Pi HAT**

**Hardware**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/4_Mics.jpg)

**Install 4 Mics Driver**

- Step 1. Download the Seeed-Voicecard driver.

```
[root@artik ~]# apt update
[root@artik ~]# apt install git
[root@artik ~]# git clone https://github.com/respeaker/seeed-voicecard
[root@artik ~]# cd seeed-voicecard
[root@artik seeed-voicecard]# git checkout remotes/origin/artikpi -b artiki
```

- Step 2. Install Seeed-Voicecard driver.

```
[root@artik seeed-voicecard]# mount -o remount,rw /lib/modules
[root@artik seeed-voicecard]# sudo mkdir -p /lib/modules/4.4.113-0533GS0F-44U-01Q5/kernel/sound/soc/codecs/
[root@artik seeed-voicecard]# sudo cp snd-soc-ac108.ko.0533GS0F-44U-01Q5 /lib/modules/4.4.113-0533GS0F-44U-01Q5/kernel/sound/soc/codecs/snd-soc-ac108.ko
[root@artik seeed-voicecard]# sudo cp snd-soc-wm8960.ko.0533GS0F-44U-01Q5 /lib/modules/4.4.113-0533GS0F-44U-01Q5/kernel/sound/soc/codecs/snd-soc-wm8960.ko
[root@artik seeed-voicecard]# sudo depmod -a
```

- Step 3. Enable 4 Mics.

```
[root@artik ~]# cd seeed-voicecard
[root@artik seeed-voicecard]# su root
[root@artik seeed-voicecard]# mkdir /sys/kernel/config/device-tree/overlays/seeed-voicecard
[root@artik seeed-voicecard]# cat seeed-4mic-voicecard-artik.dtbo > /sys/kernel/config/device-tree/overlays/seeed-voicecard/dtbo
[root@artik seeed-voicecard]#
[  574.305000] Please set data-protocol.
[  574.310000]  i2c_id number :0
[  574.310000]  ac108  codec_index :0
[  574.315000]  ac108  I2S data protocol type :1
[  574.335000] ac108_write error->[REG-0x00,val-0x12]
[  574.550000] AC108 PLL freq_in match:24000000, freq_out:24576000
[  574.550000]
[  574.640000] AC108 PLL freq_in match:24000000, freq_out:24576000
[  574.640000]

[root@artik seeed-voicecard]# cp ac108_asound.state /var/lib/alsa/asound.state
[root@artik seeed-voicecard]# cp ac108_plugin/libasound_module_pcm_ac108.so  /usr//lib/arm-linux-gnueabihf/alsa-lib/
[root@artik seeed-voicecard]# cp  asound_4mic.conf   /etc/asound.conf
[root@artik seeed-voicecard]# alsactl --file=ac108_asound.state restore
```

!!!warning
    Please run Step 3 again after the rebooting, or else it can't detect the seeed voicecard.

- Step 4. Use the arecord to list the record devices.

```
[root@artik seeed-voicecard]# arecord -L
null
    Discard all samples (playback) or generate zero samples (capture)
pulse
    PulseAudio Sound Server
default
    Playback/recording through the PulseAudio sound server
playback
dmixed
ac108
sysdefault:CARD=Audio
    Artik530 raptor Audio,
    Default Audio Device
dmix:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Direct sample mixing device
dsnoop:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Direct sample snooping device
hw:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Direct hardware device without any conversions
plughw:CARD=Audio,DEV=0
    Artik530 raptor Audio,
    Hardware device with all software conversions
sysdefault:CARD=seeed4micvoicec
    seeed-4mic-voicecard,
    Default Audio Device
dmix:CARD=seeed4micvoicec,DEV=0
    seeed-4mic-voicecard,
    Direct sample mixing device
dsnoop:CARD=seeed4micvoicec,DEV=0
    seeed-4mic-voicecard,
    Direct sample snooping device
hw:CARD=seeed4micvoicec,DEV=0
    seeed-4mic-voicecard,
    Direct hardware device without any conversions
plughw:CARD=seeed4micvoicec,DEV=0
    seeed-4mic-voicecard,
    Hardware device with all software conversions
```

**Capture Audio**

- Start recording using the Command Line

```
arecord -Dac108 -f S16_LE -r 48000  -c 4 /tmp/test.wav
```

- Start recording using Python

    - Step 1. Install pyaudio package by below commands

      ```
      apt install python-pyaudio
      ```

    - Step 2. Use a text editor like vi to create this [recorder_4Mics.py](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/recorder_4Mics.py) code file, which records a 10-sec audio clip called test.wav.

```python
import pyaudio
import wave

FORMAT = pyaudio.paInt16
CHANNELS = 4
RATE = 48000
CHUNK = 1024
RECORD_SECONDS = 10
WAVE_OUTPUT_FILENAME = "test.wav"

audio = pyaudio.PyAudio()

# start Recording
stream = audio.open(format=FORMAT, channels=CHANNELS, rate=RATE, input=True, frames_per_buffer=CHUNK)
print "recording audio..."
frames = []

threshold = 800
for i in range(0, int(RATE / CHUNK * RECORD_SECONDS)):
   data = stream.read(CHUNK)
   frames.append(data)
print "done recording"

# stop Recording
stream.stop_stream()
stream.close()
audio.terminate()

waveFile = wave.open(WAVE_OUTPUT_FILENAME, 'wb')
waveFile.setnchannels(CHANNELS)
waveFile.setsampwidth(audio.get_sample_size(FORMAT))
waveFile.setframerate(RATE)
waveFile.writeframes(b''.join(frames))
waveFile.close()
```

!!!warning
    For more information, such as play with Alexa/DuerOS, please refer to [ReSpeaker 4-Mic Array for Raspberry Pi](http://wiki.seeedstudio.com/ReSpeaker_4_Mic_Array_for_Raspberry_Pi/).

**Play with Mic Array v2.0**

**Hardware**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/usb_4Mics.jpg)

**Capture Audio**

- Start recording using the Command Line

```Python
arecord -D plughw:1,0 -f cd test.wav # record, please use the arecord -l to check the card and hardware first
aplay -D plughw:1,0 -f cd test.wav # play, please use the aplay -l to check the card and hardware first
arecord -D plughw:1,0 -f cd |aplay -D plughw:1,0 -f cd # record and play at the same time
```

- Start recording using Python

    - Step 1, We need to run the following script to get the device index number of Mic Array:

    ```Python
    apt install python-pip
    pip install pyaudio
    cd ~
    nano get_index.py
    ```

    - Step 2, copy below code and paste on [get_index.py](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/get_index.py).

```Python
import pyaudio

p = pyaudio.PyAudio()
info = p.get_host_api_info_by_index(0)
numdevices = info.get('deviceCount')

for i in range(0, numdevices):
        if (p.get_device_info_by_host_api_device_index(0, i).get('maxInputChannels')) > 0:
            print "Input Device id ", i, " - ", p.get_device_info_by_host_api_device_index(0, i).get('name')
```

- Step 3, press Ctrl + X to exit and press Y to save.

- Step 4, run 'sudo python get_index.py' and we will see the device ID as below.

```
Input Device id  0  -  Artik530 raptor Audio: - (hw:0,0)
Input Device id  2  -  ReSpeaker 4 Mic Array (UAC1.0): USB Audio (hw:1,0)
Input Device id  3  -  sysdefault
Input Device id  4  -  pulse
Input Device id  8  -  default
```

- Step 5, change `RESPEAKER_INDEX = 2` to index number. Run python script [record.py](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/record.py) to record a speech.

```Python
import pyaudio
import wave

RESPEAKER_RATE = 16000
RESPEAKER_CHANNELS = 1 # change base on firmwares, default_firmware.bin as 1 or i6_firmware.bin as 6
RESPEAKER_WIDTH = 2
# run getDeviceInfo.py to get index
RESPEAKER_INDEX = 2  # refer to input device id
CHUNK = 1024
RECORD_SECONDS = 5
WAVE_OUTPUT_FILENAME = "output.wav"

p = pyaudio.PyAudio()

stream = p.open(
            rate=RESPEAKER_RATE,
            format=p.get_format_from_width(RESPEAKER_WIDTH),
            channels=RESPEAKER_CHANNELS,
            input=True,
            input_device_index=RESPEAKER_INDEX,)

print("* recording")

frames = []

for i in range(0, int(RESPEAKER_RATE / CHUNK * RECORD_SECONDS)):
    data = stream.read(CHUNK)
    frames.append(data)

print("* done recording")

stream.stop_stream()
stream.close()
p.terminate()

wf = wave.open(WAVE_OUTPUT_FILENAME, 'wb')
wf.setnchannels(RESPEAKER_CHANNELS)
wf.setsampwidth(p.get_sample_size(p.get_format_from_width(RESPEAKER_WIDTH)))
wf.setframerate(RESPEAKER_RATE)
wf.writeframes(b''.join(frames))
wf.close()
```

!!!warning
    For more information, such as play with DOA/LEDs, please refer to [ReSpeaker Mic Array v2.0](http://wiki.seeedstudio.com/ReSpeaker_Mic_Array_v2.0/).

## Play with GrovePi+

**Install dependencies**

```
apt install g++ libi2c-dev
apt install python-dev
apt install python-smbus
apt install libffi-dev
apt install python-pip
pip install setuptools
pip install smbus-cffi
pip install numpy
```

**I2C using Python with GrovePi+ Shield**

- Step 1. Download the files from github.

```
cd ~
git clone https://github.com/DexterInd/GrovePi.git
```

- Step 2. Modify the source code /root/GrovePi/Software/Cpp/grovepi.cpp and add one line as shown.

```c++
void GrovePi::SMBusName(char *smbus_name)
{
	unsigned int hw_revision = gpioHardwareRevision();
	unsigned int smbus_rev;

	if(hw_revision < 4)
		// type 1
		smbus_rev = 1;
	else if(hw_revision < 16)
		// type 2
		smbus_rev = 2;
	else
		// type 3
		smbus_rev = 3;

	if(smbus_rev == 2 || smbus_rev == 3)
		strcpy(smbus_name, "/dev/i2c-1");
	else
		strcpy(smbus_name, "/dev/i2c-0");
  strcpy(smbus_name, "/dev/i2c-1"); //add this line to enable the I2C for eagleye_530s
}
```

- Step 3. Modify the source code /root/GrovePi/Software/Python/grovepi.py
 and comment as shown.

```python
if sys.platform == 'uwp':
	import winrt_smbus as smbus
	bus = smbus.SMBus(1)
else:
	import smbus
#	import RPi.GPIO as GPIO
#	rev = GPIO.RPI_REVISION
#	if rev == 2 or rev == 3:
	bus = smbus.SMBus(1)
#	else:
#		bus = smbus.SMBus(0)
```

- Step 4. Every time we reset the board, run the following two commands. Put them in a bash file to make it automatic.

```
mkdir /sys/kernel/config/device-tree/overlays/i2c
cat /boot/overlays/s5p4418-artik533-compy-i2c1.dtbo > /sys/kernel/config/device-tree/overlays/i2c/dtbo
```

!!!warning
    Please run Step 4 commands after rebooting.

- Step 5. Please attach the Grove-Led and Grove-Rotary Angle Sensor to GrovePi as below.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/GrovePi_Demo.jpg)

- Step 6. Run python grove_rotary_angle_sensor.py.

```
cd ~/GrovePi/Software/Python/
python grove_rotary_angle_sensor.py
```

Here is the code.

```python
import time
import grovepi

# Connect the Grove Rotary Angle Sensor to analog port A0
# SIG,NC,VCC,GND
potentiometer = 0

# Connect the LED to digital port D5
# SIG,NC,VCC,GND
led = 5

grovepi.pinMode(potentiometer,"INPUT")
grovepi.pinMode(led,"OUTPUT")
time.sleep(1)

# Reference voltage of ADC is 5v
adc_ref = 5

# Vcc of the grove interface is normally 5v
grove_vcc = 5

# Full value of the rotary angle is 300 degrees, as per it's specs (0 to 300)
full_angle = 300

while True:
    try:
        # Read sensor value from potentiometer
        sensor_value = grovepi.analogRead(potentiometer)

        # Calculate voltage
        voltage = round((float)(sensor_value) * adc_ref / 1023, 2)

        # Calculate rotation in degrees (0 to 300)
        degrees = round((voltage * full_angle) / grove_vcc, 2)

        # Calculate LED brightess (0 to 255) from degrees (0 to 300)
        brightness = int(degrees / full_angle * 255)

        # Give PWM output to LED
        grovepi.analogWrite(led,brightness)

        print("sensor_value = %d voltage = %.2f degrees = %.1f brightness = %d" %(sensor_value, voltage, degrees, brightness))
    except KeyboardInterrupt:
        grovepi.analogWrite(led,0)
        break
    except IOError:
        print ("Error")

```

- Step 7. The Led will change the brightness while the rotary angle sensor is rotating. We also see the terminal information as below.

```
[root@artik Python]# python grove_rotary_angle_sensor.py
sensor_value = 246 voltage = 1.20 degrees = 72.0 brightness = 61
sensor_value = 247 voltage = 1.21 degrees = 72.6 brightness = 61
sensor_value = 258 voltage = 1.26 degrees = 75.6 brightness = 64
sensor_value = 274 voltage = 1.34 degrees = 80.4 brightness = 68
sensor_value = 296 voltage = 1.45 degrees = 87.0 brightness = 73
sensor_value = 318 voltage = 1.55 degrees = 93.0 brightness = 79
sensor_value = 340 voltage = 1.66 degrees = 99.6 brightness = 84
sensor_value = 363 voltage = 1.77 degrees = 106.2 brightness = 90
sensor_value = 387 voltage = 1.89 degrees = 113.4 brightness = 96
```

!!!warning:
    For more Grove sensors, please refer to [DexterInd Python Library](https://github.com/DexterInd/GrovePi). We do not test all the sensors' compatiblity with Eagleye 530s. Please contact techsupport if any issue.  

## Play with Shield

**Play with Relay Boards**

**Hardware**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/relay_shield.jpg)

**Software**

- Step 1. Run below command to enable the I2C. 

```
mkdir /sys/kernel/config/device-tree/overlays/i2c
cat /boot/overlays/s5p4418-artik533-compy-i2c1.dtbo > /sys/kernel/config/device-tree/overlays/i2c/dtbo
```

!!!warning
    Every time we reset the board, run the following two commands. Put them in a bash file to make it automatic.

- Step 2. Run i2cdetect to detect the relay shield.

```
[root@artik ~]# i2cdetect -y -r 1
     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
00:          -- -- -- -- -- -- -- -- -- -- -- -- --
10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
20: 20 -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
70: -- -- -- -- -- -- -- --
```

- Step 3. Run the below commands to run the relay_lib_seeed_test.py. 

```
[root@artik ~]# cd ~
[root@artik ~]# git clone https://github.com/johnwargo/Seeed-Studio-Relay-Board.git
[root@artik ~]# cd Seed-Studio-Relay-Board/
[root@artik Seed-Studio-Relay-Board]# python relay_lib_seeed_test.py
Turning all relays ON
Turning all relays OFF
Turning relay 1 ON
Turning relay 1 OFF
Turning relay 2 ON
Turning relay 2 OFF
Turning relay 3 ON
Turning relay 3 OFF
Turning relay 4 ON
Turning relay 4 OFF
```

!!!warning
    For more information, please refer to [Raspberry Pi Relay Board v1.0](http://wiki.seeedstudio.com/Raspberry_Pi_Relay_Board_v1.0/).

**Play with RS232 Boards**

**Hardware**

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/rs232_shield.jpg)

- Step 1. Connect the USB cable to power source.
- Step 2. Connect the RS232 cable between the RS232 sheild and PC.

**Software**

- Step 1. Open [putty](https://www.putty.org/) at PC side and config as below. The COM must be set as the device manager. In our case the COM port allocated is COM9.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Com.png)

- Step 2. Set the PuTTY configuration as follows:
    - Set the “Serial line” as the COM port number found in step 3.
    - Set the COM speed to "115200".
    - Set the connection type to "Serial".
    - Save the session under Eagleye 530s.
- Step 3. Select your saved session and click the “Open” button.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Putty_setup.png)

- Step 4. The username and password are root.
- Step 5. We will see the terminal as below.

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Putty_normal_boot.png)

!!!warning
    For more information, please refer to [Raspberry Pi RS232 Board v1.0](http://wiki.seeedstudio.com/Raspberry_Pi_R232_Board_v1.0/).

**Play with Breakout Board**

Raspberry Pi Breakout Board, it also provides power, state indicator light, button and universal transistor,such as NPN, PNP, N-MOS, P-MOS. It works well with Eagleye_530s. 

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/breakout_shield.jpg)

!!!warning
    For more information, please refer to [Raspberry Pi Breakout Board v1.0](http://wiki.seeedstudio.com/Raspberry_Pi_Breakout_Board_v1.0/).


## FAQs

- Q1: Is Eagleye 530s compatiable with Raspberry Pi enclosures?

A1: Yes. Here are the compatiable list. 

| SKU       | Description                                                                                                    | Comments                             |
|-----------|----------------------------------------------------------------------------------------------------------------|--------------------------------------|
| 103010002 | [GrovePi+](https://www.seeedstudio.com/GrovePi%2B-p-2241.html)                                                 | Refer to Play with Grovepi+          |
| 103030030 | [Raspberry Pi Breakout Board v1.0](https://www.seeedstudio.com/s/Raspberry-Pi-Breakout-Board-v1.0-p-2410.html) | Refer to Play with Shield            |
| 103030029 | [Raspberry Pi Relay Board v1.0](https://www.seeedstudio.com/Raspberry-Pi-Relay-Board-v1.0-p-2409.html)         | Refer to Play with Shield            |
| 103030028 | [Raspberry Pi RS232 Board v1.0](https://www.seeedstudio.com/Raspberry-Pi-RS232-Board-v1.0-p-2408.html)         | Refer to Play with Shield            |
| 114990835 | [Raspberry Pi HDMI LCD (7 inch)](https://www.seeedstudio.com/Raspberry-Pi-HDMI-LCD-%287-inch%29-p-2763.html)   | Display works well except the touch. |

- Q2: How to set the auto-boot function?

A2: Find the D401 diode as below picture, remove D401 diode by soldering, short the D401's two pins by soldering a solder dot. 

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Auto_boot_1.jpg)

![](https://github.com/SeeedDocument/Eagleye_530s/raw/master/img/Auto_boot_2.jpg)


## Resources

- **[PDF]** [ARTIK™ 530s SoM Module Datasheet](https://developer.artik.io/downloads/hw-datasheet-artik-530-v1-0-pdf/download)
- **[Certification]** [CE Certificate&Report](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/CE%20Certificate%26Report.zip)
- **[Certification]** [IC Certificate&Report](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/IC%20Certificate%26Report.zip)
- **[Certification]** [FCC Certificate&Report](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/FCC%20Certificate%26Report.zip)
- **[PDF]** [Eagleye 530s User Guide](https://github.com/SeeedDocument/Eagleye_530s/raw/master/res/Eagleye%20530s%20User%20Guide.pdf)
- **[More Reading]** [ARTIK™ 530s](https://www.artik.io/modules/artik-530/)
- **[More Reading]** [Samsung ARTIK™ IoT platform](https://developer.artik.io/documentation/artik/getting-started/)
- **[More Reading]** [Facial-Recog Project](https://developer.artik.io/documentation/artik/projects/facial-recog.html)

## Tech Support
Please submit any technical issue into our [forum](http://forum.seeedstudio.com/).
<br /><p style="text-align:center"><a href="https://www.seeedstudio.com/act-4.html?utm_source=wiki&utm_medium=wikibanner&utm_campaign=newproducts" target="_blank"><img src="https://github.com/SeeedDocument/Wiki_Banner/raw/master/new_product.jpg" /></a></p>