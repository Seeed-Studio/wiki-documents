"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[56624],{15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>g});var i=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=r,g=u["".concat(s,".").concat(c)]||u[c]||h[c]||o;return n?i.createElement(g,a(a({ref:t},d),{},{components:n})):i.createElement(g,a({ref:t},d))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,a[1]=l;for(var p=2;p<o;p++)a[p]=n[p];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},92782:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(58168),r=(n(96540),n(15680));const o={description:"Grove - RGB LED Ring (20 - WS2813 Mini)",title:"Grove - RGB LED Ring (20 - WS2813 Mini)",keywords:["Grove"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/Grove-LED_ring",last_update:{date:"1/7/2023",author:"shuxu hu"}},a=void 0,l={unversionedId:"Sensor/Grove/Grove_Accessories/LED/Grove-LED_ring",id:"Sensor/Grove/Grove_Accessories/LED/Grove-LED_ring",title:"Grove - RGB LED Ring (20 - WS2813 Mini)",description:"Grove - RGB LED Ring (20 - WS2813 Mini)",source:"@site/docs/Sensor/Grove/Grove_Accessories/LED/Grove-LED_ring.md",sourceDirName:"Sensor/Grove/Grove_Accessories/LED",slug:"/Grove-LED_ring",permalink:"/Grove-LED_ring",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/Grove/Grove_Accessories/LED/Grove-LED_ring.md",tags:[],version:"current",lastUpdatedBy:"shuxu hu",lastUpdatedAt:1673049600,formattedLastUpdatedAt:"Jan 7, 2023",frontMatter:{description:"Grove - RGB LED Ring (20 - WS2813 Mini)",title:"Grove - RGB LED Ring (20 - WS2813 Mini)",keywords:["Grove"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/Grove-LED_ring",last_update:{date:"1/7/2023",author:"shuxu hu"}},sidebar:"ProductSidebar",previous:{title:"Grove - RGB LED Stick (10 - WS2813 Mini)",permalink:"/Grove-RGB_LED_Stick-10-WS2813_Mini"},next:{title:"Grove - LED Socket Kit",permalink:"/Grove-LED_Socket_Kit"}},s={},p=[{value:"Feature",id:"feature",level:2},{value:"Signal break-point continuous transmission",id:"signal-break-point-continuous-transmission",level:3},{value:"Specification",id:"specification",level:2},{value:"Typical applications",id:"typical-applications",level:2},{value:"Hardware Overview",id:"hardware-overview",level:2},{value:"Pin Out",id:"pin-out",level:3},{value:"Hardware Detail",id:"hardware-detail",level:3},{value:"Platforms Supported",id:"platforms-supported",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Play With Arduino",id:"play-with-arduino",level:3},{value:"Hardware",id:"hardware",level:4},{value:"Software",id:"software",level:4},{value:"\u2068buttoncycler\u2069",id:"buttoncycler",level:4},{value:"Schematic Online Viewer",id:"schematic-online-viewer",level:2},{value:"Resources",id:"resources",level:2},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2}],d={toc:p},u="wrapper";function h(e){let{components:t,...n}=e;return(0,r.yg)(u,(0,i.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/img/main.jpg",alt:"pir",width:600,height:"auto"})),(0,r.yg)("p",null,"The Grove - RGB LED Ring (20 - WS2813 Mini) is a mini version of ",(0,r.yg)("a",{parentName:"p",href:"https://www.seeedstudio.com/WS2813-Digital-RGB-LED-Ring-p-2871.html"},"WS2813 Digital RGB LED Ring"),". The RGB LED Ring are 3535-sized LEDs with an embedded microcontroller inside the LED. The WS2813s are each addressable as the driver chip is located inside the LED.\nEach LED has a constrant current drive so the color will be very consistent even if the change of the voltage."),(0,r.yg)("iframe",{width:"800",height:"450",src:"https://www.youtube.com/embed/zQj8RRJcZsk",frameborder:"0",allow:"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),(0,r.yg)("p",null,(0,r.yg)("a",{parentName:"p",href:"https://www.seeedstudio.com/Grove-RGB-LED-Ring-20-WS2813-Min-p-3227.html"},(0,r.yg)("p",null,(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/common/Get_One_Now_Banner.png",alt:"pir",width:600,height:"auto"})))),(0,r.yg)("h2",{id:"feature"},"Feature"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The control circuit and RGB chip are integrated in a 3535 components, to form an external control pixel."),(0,r.yg)("li",{parentName:"ul"},"Intelligent Reverse-connection protection."),(0,r.yg)("li",{parentName:"ul"},"Built-in signal reshaping circuit"),(0,r.yg)("li",{parentName:"ul"},"256 gray level and 16777216 full-color display"),(0,r.yg)("li",{parentName:"ul"},"Serial cascade interface, data receiving and decoding depend on just one signal line."),(0,r.yg)("li",{parentName:"ul"},"Data transmitting at speeds of up to 800Kbps."),(0,r.yg)("li",{parentName:"ul"},"Dual-signal wires version, signal break-point continuous transmission.")),(0,r.yg)("h3",{id:"signal-break-point-continuous-transmission"},"Signal break-point continuous transmission"),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Outsourcing/104020108/img/LED_RFBP.jpg",alt:"pir",width:600,height:"auto"})),(0,r.yg)("p",null,"As long as not two or more adjacent LEDs are broken, the remaining LEDs will be able to work normally."),(0,r.yg)("h2",{id:"specification"},"Specification"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Item"),(0,r.yg)("th",{parentName:"tr",align:null},"Value"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Power"),(0,r.yg)("td",{parentName:"tr",align:null},"3.3V/5V")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Quiescent Current"),(0,r.yg)("td",{parentName:"tr",align:null},"0.7mA/LED")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"RGB Channel Constant Current"),(0,r.yg)("td",{parentName:"tr",align:null},"16mA/LED")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Refresh Frequency"),(0,r.yg)("td",{parentName:"tr",align:null},"2KHz")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Reset Time"),(0,r.yg)("td",{parentName:"tr",align:null},">280\u03bcs")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Operating Temperature"),(0,r.yg)("td",{parentName:"tr",align:null},"-25\uff5e85\u2103")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Storage Temperature"),(0,r.yg)("td",{parentName:"tr",align:null},"-40\uff5e105\u2103")))),(0,r.yg)("h2",{id:"typical-applications"},"Typical applications"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Guardrail tube series, point light display series, flexible/rigid strips series, module series applications. "),(0,r.yg)("li",{parentName:"ul"},"Lighting stage costumes, innovative gadgets or any other electronic products.")),(0,r.yg)("h2",{id:"hardware-overview"},"Hardware Overview"),(0,r.yg)("h3",{id:"pin-out"},"Pin Out"),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/img/pinout.jpg",alt:"pir",width:600,height:"auto"})),(0,r.yg)("h3",{id:"hardware-detail"},"Hardware Detail"),(0,r.yg)("hr",null),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"WS2813B-Mini")),(0,r.yg)("p",null,"WS2813-Mini is an intelligent control LED light source that the control circuit and RGB chip are integrated in a package of 3535 components. Its internal include intelligent digital port data latch and signal reshaping amplification drive circuit. Also include a precision internal oscillator and a 12V voltage programmable constant current control part, which achieves highly consistent color effect."),(0,r.yg)("h2",{id:"platforms-supported"},"Platforms Supported"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Arduino"),(0,r.yg)("th",{parentName:"tr",align:null},"Raspberry Pi"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("p",null,(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/arduino_logo.jpg",alt:"pir",width:200,height:"auto"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("p",null,(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/raspberry_pi_logo_n.jpg",alt:"pir",width:200,height:"auto"})))))),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"},"    The platforms mentioned above as supported is/are an indication of the module's software or theoritical compatibility. We only provide software library or code examples for Arduino platform in most cases. It is not possible to provide software library / demo code for all possible MCU platforms. Hence, users have to write their own software library.\n"))),(0,r.yg)("h2",{id:"getting-started"},"Getting Started"),(0,r.yg)("h3",{id:"play-with-arduino"},"Play With Arduino"),(0,r.yg)("h4",{id:"hardware"},"Hardware"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Seeeduino V4.2"),(0,r.yg)("th",{parentName:"tr",align:null},"Base Shield"),(0,r.yg)("th",{parentName:"tr",align:null},"Grove - RGB LED Ring"),(0,r.yg)("th",{parentName:"tr",align:null},"Grove - Button"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("p",null,(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/seeeduino_v4.2.jpg",alt:"pir",width:600,height:"auto"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("p",null,(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/base_shield.jpg",alt:"pir",width:600,height:"auto"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("p",null,(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/img/thumbnail.jpg",alt:"pir",width:600,height:"auto"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("p",null,(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove_Button/img/button_s.jpg",alt:"pir",width:600,height:"auto"})))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Seeeduino-V4.2-p-2517.html"},"Get ONE Now")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Base-Shield-V2-p-1378.html"},"Get ONE Now")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-RGB-LED-Ring-20-WS2813-Min-p-3227.html"},"Get ONE Now")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-Button-p-766.html"},"Get ONE Now"))))),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"},"    **1.** Please plug the USB cable gently, otherwise you may damage the port. Please use the USB cable with 4 wires inside, the 2 wires cable can't transfer data. If you are not sure about the wire you have, you can click [here](https://www.seeedstudio.com/Micro-USB-Cable-48cm-p-1475.html) to buy \n\n    **2.** Each Grove module comes with a Grove cable when you buy. In case you lose the Grove cable, you can click [here](https://www.seeedstudio.com/Grove-Universal-4-Pin-Buckled-20cm-Cable-%285-PCs-pack%29-p-936.html) to buy.\n"))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 1.")," Connect Grove - Button to port D2 of Grove - Base Shield.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 2.")," Connect the Grove - RGB LED Ring to port D6 of Grove-Base Shield.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 3.")," Plug Grove - Base Shield into Seeeduino."))),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"}," \t\t",(0,r.yg)("strong",{parentName:"p"},"1.")," If you are using Arduino UNO, connect to the DC power supply is recommended to avoid the maximum Vcc voltage ripple to exceed 100mV."),(0,r.yg)("p",{parentName:"admonition"}," \t\t",(0,r.yg)("strong",{parentName:"p"},"2.")," If you are using Seeeduino V4.2, you do not need to connect to DC power supply. However, if you change to supply Grove with 3V3 the motherboard will restart when power is on. Please note, this will not affect the usage.")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 4.")," Connect Seeeduino to PC via a USB cable.")),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/img/with_ard.jpg",alt:"pir",width:600,height:"auto"})),(0,r.yg)("admonition",{type:"warning"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"},"    Hot swap is not supported, you may want to disconnect arduino from the power source before any replacement or change.\n"))),(0,r.yg)("p",null,"Now, we will demonstrate you how to run the code 'buttoncycler'. This is a demonstration on how to use an additional input device(button) to trigger changes on your LED ring. Similar procedure if you wish to run other programs, the only change is you need to disconnect button from port D2 of base shield as you are not using it."),(0,r.yg)("h4",{id:"software"},"Software"),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"},"    If this is the first time you work with Arduino, we strongly recommend you to see [Getting Started with Arduino](https://wiki.seeedstudio.com/Getting_Started_with_Arduino/) before the start.\n"))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 1.")," Download the ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/Seeed-Studio/Seeed_LED_Ring.git"},"Grove-RGB_LED_Ring-20-WS2813Mini")," Library from Github.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 2.")," Refer to ",(0,r.yg)("a",{parentName:"p",href:"https://wiki.seeedstudio.com/How_to_install_Arduino_Library"},"How to install library")," to install library for Arduino.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 3.")," Restart the Arduino IDE. Open the example, you can open it in the following three ways\uff1a"),(0,r.yg)("ol",{parentName:"li"},(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Open it directly in the Arduino IDE via the path: ",(0,r.yg)("strong",{parentName:"p"},"File --\x3e Examples --\x3eAdafruit NeoPixel--\x3ebuttoncycler"),". "),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/img/ard1.jpg",alt:"pir",width:600,height:"auto"}))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Open it in your computer by click the ",(0,r.yg)("strong",{parentName:"p"},"basic_demo.ino")," which you can find in the folder ",(0,r.yg)("strong",{parentName:"p"},"XXXX\\Arduino\\libraries\\Seeed_LED_Ring\\examples\\\u2068buttoncycler\u2069\\\u2068buttoncycler\u2069.ino"),", ",(0,r.yg)("strong",{parentName:"p"},"XXXX")," is the location you installed the Arduino IDE."),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/img/ard2.jpg",alt:"pir",width:600,height:"auto"}))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Or, you can just click the icon "),(0,r.yg)("p",{style:{textAlign:"center"}},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/copy.jpg",alt:"pir",width:50,height:"auto"})),"in upper right corner of the code block to copy the following code into a new sketch in the Arduino IDE.")))),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"}," Due to the current limitation, the brightness of the LED is limited in the program. If you insist on adjusting the brightness limit, you can modify the setBrightness() function. But this may cause the light to not work properly.\n"))),(0,r.yg)("h4",{id:"buttoncycler"},"\u2068buttoncycler\u2069"),(0,r.yg)("p",null,"After run this code, when you press the button it will change to a new pixel animation.  Note that you need to press the button once to start the first animation!"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},"\n#include \"Adafruit_NeoPixel.h\"\n\n#define BUTTON_PIN   2    // Digital IO pin connected to the button.  This will be\n                          // driven with a pull-up resistor so the switch should\n                          // pull the pin to ground momentarily.  On a high -> low\n                          // transition the button press logic will execute.\n\n#define PIXEL_PIN    6    // Digital IO pin connected to the NeoPixels.\n\n#define PIXEL_COUNT 20\n\n// Parameter 1 = number of pixels in strip,  neopixel stick has 8\n// Parameter 2 = pin number (most are valid)\n// Parameter 3 = pixel type flags, add together as needed:\n//   NEO_RGB     Pixels are wired for RGB bitstream\n//   NEO_GRB     Pixels are wired for GRB bitstream, correct for neopixel stick\n//   NEO_KHZ400  400 KHz bitstream (e.g. FLORA pixels)\n//   NEO_KHZ800  800 KHz bitstream (e.g. High Density LED strip), correct for neopixel stick\nAdafruit_NeoPixel strip = Adafruit_NeoPixel(PIXEL_COUNT, PIXEL_PIN, NEO_GRB + NEO_KHZ800);\n\nbool oldState = HIGH;\nint showType = 0;\n\nvoid setup() {\n  pinMode(BUTTON_PIN, INPUT_PULLUP);\n  strip.setBrightness(255);\n  strip.begin();\n  strip.show(); // Initialize all pixels to 'off'\n}\n\nvoid loop() {\n  // Get current button state.\n  bool newState = digitalRead(BUTTON_PIN);\n\n  // Check if state changed from high to low (button press).\n  if (newState == LOW && oldState == HIGH) {\n    // Short delay to debounce button.\n    delay(20);\n    // Check if button is still low after debounce.\n    newState = digitalRead(BUTTON_PIN);\n    if (newState == LOW) {\n      showType++;\n      if (showType > 9)\n        showType=0;\n      startShow(showType);\n    }\n  }\n\n  // Set the last button state to the old state.\n  oldState = newState;\n}\n\nvoid startShow(int i) {\n  switch(i){\n    case 0: colorWipe(strip.Color(0, 0, 0), 50);    // Black/off\n            break;\n    case 1: colorWipe(strip.Color(255, 0, 0), 50);  // Red\n            break;\n    case 2: colorWipe(strip.Color(0, 255, 0), 50);  // Green\n            break;\n    case 3: colorWipe(strip.Color(0, 0, 255), 50);  // Blue\n            break;\n    case 4: theaterChase(strip.Color(127, 127, 127), 50); // White\n            break;\n    case 5: theaterChase(strip.Color(127,   0,   0), 50); // Red\n            break;\n    case 6: theaterChase(strip.Color(  0,   0, 127), 50); // Blue\n            break;\n    case 7: rainbow(20);\n            break;\n    case 8: rainbowCycle(20);\n            break;\n    case 9: theaterChaseRainbow(50);\n            break;\n  }\n}\n\n// Fill the dots one after the other with a color\nvoid colorWipe(uint32_t c, uint8_t wait) {\n  for(uint16_t i=0; i < strip.numPixels(); i++) {\n    strip.setPixelColor(i, c);\n    strip.show();\n    delay(wait);\n  }\n}\n\nvoid rainbow(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j<256; j++) {\n    for(i=0; i<strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel((i+j) & 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\n// Slightly different, this makes the rainbow equally distributed throughout\nvoid rainbowCycle(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel\n    for(i=0; i< strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\n//Theatre-style crawling lights.\nvoid theaterChase(uint32_t c, uint8_t wait) {\n  for (int j=0; j<10; j++) {  //do 10 cycles of chasing\n    for (int q=0; q < 3; q++) {\n      for (int i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, c);    //turn every third pixel on\n      }\n      strip.show();\n\n      delay(wait);\n\n      for (int i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, 0);        //turn every third pixel off\n      }\n    }\n  }\n}\n\n//Theatre-style crawling lights with rainbow effect\nvoid theaterChaseRainbow(uint8_t wait) {\n  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel\n    for (int q=0; q < 3; q++) {\n      for (int i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on\n      }\n      strip.show();\n\n      delay(wait);\n\n      for (int i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, 0);        //turn every third pixel off\n      }\n    }\n  }\n}\n\n// Input a value 0 to 255 to get a color value.\n// The colours are a transition r - g - b - back to r.\nuint32_t Wheel(byte WheelPos) {\n  WheelPos = 255 - WheelPos;\n  if(WheelPos < 85) {\n    return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);\n  }\n  if(WheelPos < 170) {\n    WheelPos -= 85;\n    return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);\n  }\n  WheelPos -= 170;\n  return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);\n}\n\n")),(0,r.yg)("p",null,"!!! Attention\nThe library file may be updated. This code may not be applicable to the updated library file, so we recommend that you use the first two methods."),(0,r.yg)("admonition",{type:"success"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"},"    If everything goes well, you will be able to see the first animation of the LED ring, and you will be able to trigger the new animation once you press the button.\n"))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Other Examples:")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"RGBW strand test")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},"\n#include \"Adafruit_NeoPixel.h\"\n#ifdef __AVR__\n  #include <avr/power.h>\n#endif\n\n#define PIN 6\n\n#define NUM_LEDS 20\n\n#define BRIGHTNESS 255\n\nAdafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, PIN, NEO_GRBW + NEO_KHZ800);\n\nbyte neopix_gamma[] = {\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,\n    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,\n    2,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  5,  5,  5,\n    5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9, 10,\n   10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16,\n   17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25,\n   25, 26, 27, 27, 28, 29, 29, 30, 31, 32, 32, 33, 34, 35, 35, 36,\n   37, 38, 39, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 50,\n   51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 66, 67, 68,\n   69, 70, 72, 73, 74, 75, 77, 78, 79, 81, 82, 83, 85, 86, 87, 89,\n   90, 92, 93, 95, 96, 98, 99,101,102,104,105,107,109,110,112,114,\n  115,117,119,120,122,124,126,127,129,131,133,135,137,138,140,142,\n  144,146,148,150,152,154,156,158,160,162,164,167,169,171,173,175,\n  177,180,182,184,186,189,191,193,196,198,200,203,205,208,210,213,\n  215,218,220,223,225,228,231,233,236,239,241,244,247,249,252,255 };\n\n\nvoid setup() {\n  // This is for Trinket 5V 16MHz, you can remove these three lines if you are not using a Trinket\n  #if defined (__AVR_ATtiny85__)\n    if (F_CPU == 16000000) clock_prescale_set(clock_div_1);\n  #endif\n  // End of trinket special code\n  strip.setBrightness(BRIGHTNESS);\n  strip.begin();\n  strip.show(); // Initialize all pixels to 'off'\n}\n\nvoid loop() {\n  // Some example procedures showing how to display to the pixels:\n  colorWipe(strip.Color(255, 0, 0), 50); // Red\n  colorWipe(strip.Color(0, 255, 0), 50); // Green\n  colorWipe(strip.Color(0, 0, 255), 50); // Blue\n  colorWipe(strip.Color(0, 0, 0, 255), 50); // White\n\n  whiteOverRainbow(20,75,5);  \n\n  pulseWhite(5); \n\n  // fullWhite();\n  // delay(2000);\n\n  rainbowFade2White(3,3,1);\n\n\n}\n\n// Fill the dots one after the other with a color\nvoid colorWipe(uint32_t c, uint8_t wait) {\n  for(uint16_t i=0; i < strip.numPixels(); i++) {\n    strip.setPixelColor(i, c);\n    strip.show();\n    delay(wait);\n  }\n}\n\nvoid pulseWhite(uint8_t wait) {\n  for(int j = 0; j < 256 ; j++){\n      for(uint16_t i=0; i < strip.numPixels(); i++) {\n          strip.setPixelColor(i, strip.Color(0,0,0, neopix_gamma[j] ) );\n        }\n        delay(wait);\n        strip.show();\n      }\n\n  for(int j = 255; j >= 0 ; j--){\n      for(uint16_t i=0; i<strip.numPixels(); i++) {\n          strip.setPixelColor(i, strip.Color(0,0,0, neopix_gamma[j] ) );\n        }\n        delay(wait);\n        strip.show();\n      }\n}\n\n\nvoid rainbowFade2White(uint8_t wait, int rainbowLoops, int whiteLoops) {\n  float fadeMax = 100.0;\n  int fadeVal = 0;\n  uint32_t wheelVal;\n  int redVal, greenVal, blueVal;\n\n  for(int k = 0 ; k < rainbowLoops ; k ++){\n    \n    for(int j=0; j<256; j++) { // 5 cycles of all colors on wheel\n\n      for(int i=0; i< strip.numPixels(); i++) {\n\n        wheelVal = Wheel(((i * 256 / strip.numPixels()) + j) & 255);\n\n        redVal = red(wheelVal) * float(fadeVal/fadeMax);\n        greenVal = green(wheelVal) * float(fadeVal/fadeMax);\n        blueVal = blue(wheelVal) * float(fadeVal/fadeMax);\n\n        strip.setPixelColor( i, strip.Color( redVal, greenVal, blueVal ) );\n\n      }\n\n      //First loop, fade in!\n      if(k == 0 && fadeVal < fadeMax-1) {\n          fadeVal++;\n      }\n\n      //Last loop, fade out!\n      else if(k == rainbowLoops - 1 && j > 255 - fadeMax ){\n          fadeVal--;\n      }\n\n        strip.show();\n        delay(wait);\n    }\n  \n  }\n\n\n\n  delay(500);\n\n\n  for(int k = 0 ; k < whiteLoops ; k ++){\n\n    for(int j = 0; j < 256 ; j++){\n\n        for(uint16_t i=0; i < strip.numPixels(); i++) {\n            strip.setPixelColor(i, strip.Color(0,0,0, neopix_gamma[j] ) );\n          }\n          strip.show();\n        }\n\n        delay(2000);\n    for(int j = 255; j >= 0 ; j--){\n\n        for(uint16_t i=0; i < strip.numPixels(); i++) {\n            strip.setPixelColor(i, strip.Color(0,0,0, neopix_gamma[j] ) );\n          }\n          strip.show();\n        }\n  }\n\n  delay(500);\n\n\n}\n\nvoid whiteOverRainbow(uint8_t wait, uint8_t whiteSpeed, uint8_t whiteLength ) {\n  \n  if(whiteLength >= strip.numPixels()) whiteLength = strip.numPixels() - 1;\n\n  int head = whiteLength - 1;\n  int tail = 0;\n\n  int loops = 3;\n  int loopNum = 0;\n\n  static unsigned long lastTime = 0;\n\n\n  while(true){\n    for(int j=0; j<256; j++) {\n      for(uint16_t i=0; i<strip.numPixels(); i++) {\n        if((i >= tail && i <= head) || (tail > head && i >= tail) || (tail > head && i <= head) ){\n          strip.setPixelColor(i, strip.Color(0,0,0, 255 ) );\n        }\n        else{\n          strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));\n        }\n        \n      }\n\n      if(millis() - lastTime > whiteSpeed) {\n        head++;\n        tail++;\n        if(head == strip.numPixels()){\n          loopNum++;\n        }\n        lastTime = millis();\n      }\n\n      if(loopNum == loops) return;\n    \n      head%=strip.numPixels();\n      tail%=strip.numPixels();\n        strip.show();\n        delay(wait);\n    }\n  }\n  \n}\nvoid fullWhite() {\n  \n    for(uint16_t i=0; i<strip.numPixels(); i++) {\n        strip.setPixelColor(i, strip.Color(0,0,0, 255 ) );\n    }\n      strip.show();\n}\n\n\n// Slightly different, this makes the rainbow equally distributed throughout\nvoid rainbowCycle(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j<256 * 5; j++) { // 5 cycles of all colors on wheel\n    for(i=0; i< strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\nvoid rainbow(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j<256; j++) {\n    for(i=0; i<strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel((i+j) & 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\n// Input a value 0 to 255 to get a color value.\n// The colours are a transition r - g - b - back to r.\nuint32_t Wheel(byte WheelPos) {\n  WheelPos = 255 - WheelPos;\n  if(WheelPos < 85) {\n    return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3,0);\n  }\n  if(WheelPos < 170) {\n    WheelPos -= 85;\n    return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3,0);\n  }\n  WheelPos -= 170;\n  return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0,0);\n}\n\nuint8_t red(uint32_t c) {\n  return (c >> 16);\n}\nuint8_t green(uint32_t c) {\n  return (c >> 8);\n}\nuint8_t blue(uint32_t c) {\n  return (c);\n}\n\n\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Simple")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},'\n#include "Adafruit_NeoPixel.h"\n#ifdef __AVR__\n  #include <avr/power.h>\n#endif\n\n// Which pin on the Arduino is connected to the NeoPixels?\n// On a Trinket or Gemma we suggest changing this to 1\n#define PIN            6\n\n// How many NeoPixels are attached to the Arduino?\n#define NUMPIXELS      20\n\n// When we setup the NeoPixel library, we tell it how many pixels, and which pin to use to send signals.\n// Note that for older NeoPixel strips you might need to change the third parameter--see the strandtest\n// example for more information on possible values.\nAdafruit_NeoPixel pixels = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nint delayval = 500; // delay for half a second\n\nvoid setup() {\n  // This is for Trinket 5V 16MHz, you can remove these three lines if you are not using a Trinket\n#if defined (__AVR_ATtiny85__)\n  if (F_CPU == 16000000) clock_prescale_set(clock_div_1);\n#endif\n  // End of trinket special code\n  pixels.setBrightness(255);\n  pixels.begin(); // This initializes the NeoPixel library.\n}\n\nvoid loop() {\n\n  // For a set of NeoPixels the first NeoPixel is 0, second is 1, all the way up to the count of pixels minus one.\n\n  for(int i=0;i<NUMPIXELS;i++){\n\n    // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255\n    pixels.setPixelColor(i, pixels.Color(0,150,0)); // Moderately bright green color.\n\n    pixels.show(); // This sends the updated pixel color to the hardware.\n\n    delay(delayval); // Delay for a period of time (in milliseconds).\n\n  }\n}\n\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Simple New Operator")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},'\n#include "Adafruit_NeoPixel.h"\n#ifdef __AVR__\n  #include <avr/power.h>\n#endif\n\n// Which pin on the Arduino is connected to the NeoPixels?\n// On a Trinket or Gemma we suggest changing this to 1\n#define PIN            6\n\n// How many NeoPixels are attached to the Arduino?\nint numPixel = 20;\n\n// Color order, for more information see https://github.com/adafruit/Adafruit_NeoPixel/blob/master/Adafruit_NeoPixel.h\nuint8_t colorOrder = 0x52; //or just use NEO_GBR\n\n// Define new pointer for NeoPixel\nAdafruit_NeoPixel *pixels;\n\n\nint delayval = 500; // delay for half a second\n\nvoid setup() {\n  // This is for Trinket 5V 16MHz, you can remove these three lines if you are not using a Trinket\n#if defined (__AVR_ATtiny85__)\n  if (F_CPU == 16000000) clock_prescale_set(clock_div_1);\n#endif\n  // End of trinket special code\n  \n  // Here is a good place to read numPixel & colorOrder from EEPROM or what ever.\n  // create a new NeoPixel instance with new values\n  pixels = new Adafruit_NeoPixel(numPixel, PIN, colorOrder);\n  pixels->setBrightness(255);\n  pixels->begin(); // This initializes the NeoPixel library.\n}\n\nvoid loop() {\n\n  // For a set of NeoPixels the first NeoPixel is 0, second is 1, all the way up to the count of pixels minus one.\n\n  for(int i=0;i<numPixel;i++){\n\n    // pixels.Color takes RGB values, from 0,0,0 up to 255,255,255\n    pixels->setPixelColor(i, pixels->Color(0,150,0)); // Moderately bright green color.\n\n    pixels->show(); // This sends the updated pixel color to the hardware.\n\n    delay(delayval); // Delay for a period of time (in milliseconds).\n\n  }\n}\n\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Strand test")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},"\n#include \"Adafruit_NeoPixel.h\"\n#ifdef __AVR__\n  #include <avr/power.h>\n#endif\n\n#define PIN 6\n\n// Parameter 1 = number of pixels in strip\n// Parameter 2 = Arduino pin number (most are valid)\n// Parameter 3 = pixel type flags, add together as needed:\n//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)\n//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)\n//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)\n//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)\n//   NEO_RGBW    Pixels are wired for RGBW bitstream (NeoPixel RGBW products)\nAdafruit_NeoPixel strip = Adafruit_NeoPixel(20, PIN, NEO_GRB + NEO_KHZ800);\n\n// IMPORTANT: To reduce NeoPixel burnout risk, add 1000 uF capacitor across\n// pixel power leads, add 300 - 500 Ohm resistor on first pixel's data input\n// and minimize distance between Arduino and first pixel.  Avoid connecting\n// on a live circuit...if you must, connect GND first.\n\nvoid setup() {\n  // This is for Trinket 5V 16MHz, you can remove these three lines if you are not using a Trinket\n  #if defined (__AVR_ATtiny85__)\n    if (F_CPU == 16000000) clock_prescale_set(clock_div_1);\n  #endif\n  // End of trinket special code\n\n  strip.begin();\n  strip.setBrightness(255);\n  strip.show(); // Initialize all pixels to 'off'\n}\n\nvoid loop() {\n  // Some example procedures showing how to display to the pixels:\n  colorWipe(strip.Color(255, 0, 0), 50); // Red\n  colorWipe(strip.Color(0, 255, 0), 50); // Green\n  colorWipe(strip.Color(0, 0, 255), 50); // Blue\n//colorWipe(strip.Color(0, 0, 0, 255), 50); // White RGBW\n  // Send a theater pixel chase in...\n  theaterChase(strip.Color(127, 127, 127), 50); // White\n  theaterChase(strip.Color(127, 0, 0), 50); // Red\n  theaterChase(strip.Color(0, 0, 127), 50); // Blue\n\n  rainbow(20);\n  rainbowCycle(20);\n  theaterChaseRainbow(50);\n}\n\n// Fill the dots one after the other with a color\nvoid colorWipe(uint32_t c, uint8_t wait) {\n  for(uint16_t i=0; i < strip.numPixels(); i++) {\n    strip.setPixelColor(i, c);\n    strip.show();\n    delay(wait);\n  }\n}\n\nvoid rainbow(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j<256; j++) {\n    for(i=0; i<strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel((i+j) & 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\n// Slightly different, this makes the rainbow equally distributed throughout\nvoid rainbowCycle(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel\n    for(i=0; i< strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\n//Theatre-style crawling lights.\nvoid theaterChase(uint32_t c, uint8_t wait) {\n  for (int j=0; j<10; j++) {  //do 10 cycles of chasing\n    for (int q=0; q < 3; q++) {\n      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, c);    //turn every third pixel on\n      }\n      strip.show();\n\n      delay(wait);\n\n      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, 0);        //turn every third pixel off\n      }\n    }\n  }\n}\n\n//Theatre-style crawling lights with rainbow effect\nvoid theaterChaseRainbow(uint8_t wait) {\n  for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel\n    for (int q=0; q < 3; q++) {\n      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on\n      }\n      strip.show();\n\n      delay(wait);\n\n      for (uint16_t i=0; i < strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, 0);        //turn every third pixel off\n      }\n    }\n  }\n}\n\n// Input a value 0 to 255 to get a color value.\n// The colours are a transition r - g - b - back to r.\nuint32_t Wheel(byte WheelPos) {\n  WheelPos = 255 - WheelPos;\n  if(WheelPos < 85) {\n    return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);\n  }\n  if(WheelPos < 170) {\n    WheelPos -= 85;\n    return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);\n  }\n  WheelPos -= 170;\n  return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);\n}\n\n")),(0,r.yg)("h2",{id:"schematic-online-viewer"},"Schematic Online Viewer"),(0,r.yg)("div",{className:"altium-ecad-viewer","data-project-src":"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/res/Grove%20-%20RGB%20LED%20Ring%20(20%20-%20WS2813%20Mini).zip",style:{borderRadius:"0px 0px 4px 4px",height:500,borderStyle:"solid",borderWidth:1,borderColor:"rgb(241, 241, 241)",overflow:"hidden",maxWidth:1280,maxHeight:700,boxSizing:"border-box"}}),(0,r.yg)("h2",{id:"resources"},"Resources"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"[Zip]")," ",(0,r.yg)("a",{parentName:"p",href:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/res/Grove%20-%20RGB%20LED%20Ring%20(20%20-%20WS2813%20Mini).zip"},"Grove - RGB LED Ring(20 WS2813 Mini) Eagle Files"))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"[Zip]")," ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/Seeed-Studio/Seeed_LED_Ring/archive/master.zip"},"Grove - RGB LED Ring(20 WS2813 Mini) Software Library"))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"[PDF]")," ",(0,r.yg)("a",{parentName:"p",href:"https://files.seeedstudio.com/wiki/Grove-RGB_LED_Ring-20-WS2813Mini/res/WS2813-Mini.pdf"},"Datasheet WS2813- Mini")))),(0,r.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,r.yg)("p",null,"Thank you for choosing our products! We are here to provide you with different support to ensure that your experience with our products is as smooth as possible. We offer several communication channels to cater to different preferences and needs."),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,r.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,r.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"})))}h.isMDXComponent=!0}}]);