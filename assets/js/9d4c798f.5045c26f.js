"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[21273],{15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>y});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),g=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=g(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=g(n),c=r,y=u["".concat(s,".").concat(c)]||u[c]||p[c]||l;return n?a.createElement(y,o(o({ref:t},d),{},{components:n})):a.createElement(y,o({ref:t},d))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[u]="string"==typeof e?e:r,o[1]=i;for(var g=2;g<l;g++)o[g]=n[g];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},31219:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>l,metadata:()=>i,toc:()=>g});var a=n(58168),r=(n(96540),n(15680));const l={description:"XIAO ESP32C3 Flash-storage",title:"XIAO ESP32C3 Flash-storage",keywords:["XIAO ESP32C3"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/xiaoesp32c3-flash-storage",last_update:{date:"03/03/2023",author:"Citric"}},o="XIAO ESP32C3 Data Permanently in different ways",i={unversionedId:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C3/Application/xiaoesp32c3-flash-storage",id:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C3/Application/xiaoesp32c3-flash-storage",title:"XIAO ESP32C3 Flash-storage",description:"XIAO ESP32C3 Flash-storage",source:"@site/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C3/Application/xiaoesp32c3-flash-storage.md",sourceDirName:"Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C3/Application",slug:"/xiaoesp32c3-flash-storage",permalink:"/xiaoesp32c3-flash-storage",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/SeeedStudio_XIAO/SeeedStudio_XIAO_ESP32C3/Application/xiaoesp32c3-flash-storage.md",tags:[],version:"current",lastUpdatedBy:"Citric",lastUpdatedAt:1677801600,formattedLastUpdatedAt:"Mar 3, 2023",frontMatter:{description:"XIAO ESP32C3 Flash-storage",title:"XIAO ESP32C3 Flash-storage",keywords:["XIAO ESP32C3"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/xiaoesp32c3-flash-storage",last_update:{date:"03/03/2023",author:"Citric"}},sidebar:"ProductSidebar",previous:{title:"Xiao ESP32C3 ESPHome Smart ThermoStat",permalink:"/esp32c3_smart_thermostat"},next:{title:"ESPHome Support on Seeed Studio XIAO ESP32C3",permalink:"/XIAO-ESP32C3-for-ESPHome-Support"}},s={},g=[{value:"Save Data Permanently using Preferences Library",id:"save-data-permanently-using-preferences-library",level:2},{value:"Preferences.h Library",id:"preferencesh-library",level:3},{value:"General ways to use the Preferences.h library",id:"general-ways-to-use-the-preferencesh-library",level:3},{value:"Store/get Key:value Pair data",id:"storeget-keyvalue-pair-data",level:4},{value:"Store/get String data",id:"storeget-string-data",level:4},{value:"Store Permanent Data using EEPROM",id:"store-permanent-data-using-eeprom",level:2},{value:"What is EEPROM?",id:"what-is-eeprom",level:3},{value:"Available EEPROM Functions",id:"available-eeprom-functions",level:3},{value:"General ways to use the EEPROM",id:"general-ways-to-use-the-eeprom",level:3},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2}],d={toc:g},u="wrapper";function p(e){let{components:t,...n}=e;return(0,r.yg)(u,(0,a.A)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"xiao-esp32c3-data-permanently-in-different-ways"},"XIAO ESP32C3 Data Permanently in different ways"),(0,r.yg)("p",null,"When we use development boards, many of us will want to be able to use the flash memory on the chip to store some important data. This requires a storage method that ensures that no data is lost even in the event of an abnormal development board."),(0,r.yg)("p",null,"This tutorial will introduce how to store important data on the XIAO ESP32C3's flash memory from two different storage methods as follows"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"First guide shows how to ",(0,r.yg)("strong",{parentName:"p"},"save data permanently")," on the ESP32 flash memory using the ",(0,r.yg)("inlineCode",{parentName:"p"},"Preferences.h")," library. The data held in the flash memory persists across resets or power failures. Using the ",(0,r.yg)("inlineCode",{parentName:"p"},"Preferences.h")," library is useful to save data like network credentials, API keys, threshold values, or even the last state of a GPIO. You\u2019ll learn how to save and read data from flash memory.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Second guid explains what is the XIAO ESP32C3 ",(0,r.yg)("strong",{parentName:"p"},"EEPROM")," and what it is useful for. We\u2019re also going to show you how to write and read from the EEPROM and build a project example to put the concepts learned into practice."))),(0,r.yg)("p",null,"The vast majority of this article comes from ",(0,r.yg)("a",{parentName:"p",href:"https://randomnerdtutorials.com/"},(0,r.yg)("strong",{parentName:"a"},"RandomNerdTutorials.com")),", and some of the programs and descriptions have been slightly modified to fit the XIAO ESP32C3. Special thanks to ",(0,r.yg)("a",{parentName:"p",href:"https://randomnerdtutorials.com/"},(0,r.yg)("strong",{parentName:"a"},"RandomNerdTutorials.com"))," for providing the tutorials and methods. Here is the direct link to the original source."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("a",{parentName:"p",href:"https://randomnerdtutorials.com/esp32-flash-memory/"},"ESP32 Flash Memory \u2013 Store Permanent Data (Write and Read)"))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("a",{parentName:"p",href:"https://randomnerdtutorials.com/arduino-eeprom-explained-remember-last-led-state/"},"Arduino EEPROM Explained \u2013 Remember Last LED State"))),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("a",{parentName:"p",href:"https://randomnerdtutorials.com/esp32-save-data-permanently-preferences/"},"ESP32 Save Data Permanently using Preferences Library")))),(0,r.yg)("h2",{id:"save-data-permanently-using-preferences-library"},"Save Data Permanently using Preferences Library"),(0,r.yg)("h3",{id:"preferencesh-library"},"Preferences.h Library"),(0,r.yg)("p",null,"This library is \u201cinstalled\u201d automatically when you install the XIAO ESP32C3 boards in your Arduino IDE."),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Preferences.h")," library is preferably used to store variable values through key:value pairs. Saving data permanently can be important to:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Remember the last state of a variable;")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Save settings;")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Save how many times an appliance was activated;")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},"Or any other data type you need to save permanently."))),(0,r.yg)("p",null,"If you want to use XIAO ESP32C3 to store files or very long strings or data, we recommend you to use the expansion board & SD card, we do not recommend you to use the two methods in this tutorial."),(0,r.yg)("p",null,"The following is ",(0,r.yg)("strong",{parentName:"p"},"Preferences.h Library Useful Functions")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 1"),". The ",(0,r.yg)("inlineCode",{parentName:"p"},"begin()")," method opens a \u201cstorage space\u201d with a defined namespace. The false argument means that we\u2019ll use it in read/write mode. Use true to open or create the namespace in read-only mode."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'preferences.begin("my-app", false);\n')),(0,r.yg)("p",null,"In this case, the namespace name is my-app. Namespace name is limited to 15 characters."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 2"),". Use ",(0,r.yg)("inlineCode",{parentName:"p"},"clear()")," to clear all preferences under the opened namespace (it doesn\u2019t delete the namespace):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"preferences.clear();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 3"),". Remove a key from the opened namespace:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"preferences.remove(key);\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 4"),". Use the ",(0,r.yg)("inlineCode",{parentName:"p"},"end()")," method to close the preferences under the opened namespace:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"preferences.end();\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 5"),". You should use different methods depending on the variable type you want to save."),(0,r.yg)("p",null,"When using the ",(0,r.yg)("inlineCode",{parentName:"p"},"Preferences.h")," library, you should define the data type you want to save. Later, if you want to read that data, you must know the saved data type. In other words, the data type of writing and reading should be the same."),(0,r.yg)("p",null,"You can save the following data types using ",(0,r.yg)("inlineCode",{parentName:"p"},"Preferences.h"),": char, Uchar, short, Ushort, int, Uint, long, Ulong, long64, Ulong64, float, double, bool, string and bytes."),(0,r.yg)("table",{align:"center"},(0,r.yg)("tbody",null,(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Char"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putChar(const char*key, int8_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Char"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putUChar(const char* key, int8_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Short"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putShort(const char*key, int16_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Short"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putUShort(const char* key, uint16_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Int"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putInt(const char*key, int32_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Int"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putUInt(const char* key, uint32_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Long"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putLong(const char*key, int32_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Long"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putULong(const char* key, uint32_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Long64"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putLong64(const char*key, int64_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Long64"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putULong64(const char* key, uint64_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Float"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putFloat(const char*key, const float_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Double"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putDouble(const char* key, const double_t value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Bool"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putBool(const char*key, const bool value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"String"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putString(const char* key, const String value)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Bytes"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"putBytes(const char*key, const void* value, size_t len)"))))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 6"),". Similarly, you should use different methods depending on the variable type you want to get."),(0,r.yg)("table",{align:"center"},(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Char"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getChar(const char*key, const int8_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Char"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getUChar(const char* key, const uint8_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Short"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getShort(const char*key, const int16_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Short"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getUShort(const char* key, const uint16_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Int"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getInt(const char*key, const int32_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Int"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getUInt(const char* key, const uint32_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Long"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getLong(const char*key, const int32_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Long"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getULong(const char* key, const uint32_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Long64"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getLong64(const char*key, const int64_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Unsigned Long64"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"gettULong64(const char* key, const uint64_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Float"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getFloat(const char*key, const float_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Double"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getDouble(const char* key, const double_t defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Bool"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getBool(const char*key, const bool defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"String"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getString(const char* key, const String defaultValue)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"String"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getString(const char*key, char* value, const size_t maxLen)"))),(0,r.yg)("tr",null,(0,r.yg)("td",{align:"center"},"Bytes"),(0,r.yg)("td",{align:"left"},(0,r.yg)("code",null,"getBytes(const char*key, void* buf, size_t maxLen)")))),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 7"),". Remove a Namespace"),(0,r.yg)("p",null,"In the Arduino implementation of Preferences, there is no method of completely removing a namespace. As a result, over the course of several projects, the ESP32 non-volatile storage (nvs) Preferences partition may become full. To completely erase and reformat the NVS memory used by Preferences, create a sketch that contains:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"#include <nvs_flash.h>\n\nvoid setup() {\n  nvs_flash_erase(); // erase the NVS partition and...\n  nvs_flash_init(); // initialize the NVS partition.\n  while(true);\n}\n\nvoid loop() {\n\n}\n")),(0,r.yg)("p",null,"You should download a new sketch to your board immediately after running the above, or it will reformat the NVS partition every time it is powered up."),(0,r.yg)("p",null,"For more information, you can access the Preferences.cpp file ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/espressif/arduino-esp32/blob/master/libraries/Preferences/src/Preferences.cpp"},"here"),"."),(0,r.yg)("h3",{id:"general-ways-to-use-the-preferencesh-library"},"General ways to use the Preferences.h library"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 1.")," To use the Preferences.h library to store data, first you need to include it in your sketch:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"#include <Preferences.h>\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 2.")," Then, you must initiate an instance of the Preferences library. You can call it preferences, for example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"Preferences preferences;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 3.")," In the ",(0,r.yg)("inlineCode",{parentName:"p"},"setup()"),", initialize the Serial Monitor at a baud rate of 115200."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"Serial.begin(115200);\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 4.")," Create a \u201cstorage space\u201d in the flash memory called ",(0,r.yg)("inlineCode",{parentName:"p"},"my-app")," in read/write mode. You can give it any other name."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'preferences.begin("my-app", false);\n')),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 5.")," Use get and put methods to get/store data content."),(0,r.yg)("h4",{id:"storeget-keyvalue-pair-data"},"Store/get Key:value Pair data"),(0,r.yg)("p",null,"The data saved using preferences is structured like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"namespace {\n  key:value\n}\n")),(0,r.yg)("p",null,"You can save different keys on the same namespace, for example:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"namespace {\n  key1: value1\n  key2: value2\n}\n")),(0,r.yg)("p",null,"You can also have multiple namespaces with the same key (but each key with its value):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"namespace1{\n  key:value1\n}\nnamespace2{\n  key:value2\n}\n")),(0,r.yg)("p",null,"For example, store the new value on the \u201ccounter\u201d key:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'preferences.putUInt("counter", counter);\n')),(0,r.yg)("p",null,"Then, get the value of the ",(0,r.yg)("inlineCode",{parentName:"p"},"counter")," key saved on preferences. If it doesn\u2019t find any value, it returns 0 by default (which happens when this code runs for the first time)."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'unsigned int counter = preferences.getUInt("counter", 0);\n')),(0,r.yg)("p",null,"So, your data is structured in this way:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"my-app{\n  counter: counter\n}\n")),(0,r.yg)("h4",{id:"storeget-string-data"},"Store/get String data"),(0,r.yg)("p",null,"The following codes saves your network credentials permanently on the ESP32 flash memory using ",(0,r.yg)("inlineCode",{parentName:"p"},"Preferences.h"),"."),(0,r.yg)("p",null,"Create a key called ssid that saves your SSID value (ssid variable) \u2013 use the ",(0,r.yg)("inlineCode",{parentName:"p"},"putString()")," method."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'preferences.putString("ssid", ssid);\n')),(0,r.yg)("p",null,"Add another key called password to save the password value (password variable):"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'preferences.putString("password", password);\n')),(0,r.yg)("p",null,"So, your data is structured in this way:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"my-app{\n  ssid: ssid\n  password: password\n}\n")),(0,r.yg)("p",null,"Get the SSID and password values using the ",(0,r.yg)("inlineCode",{parentName:"p"},"getString()")," method. You need to use the key name that you used to save the variables, in this case, ssid and password keys:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'String ssid = preferences.getString("ssid", ""); \nString password = preferences.getString("password", "");\n')),(0,r.yg)("p",null,"As a second argument to the ",(0,r.yg)("inlineCode",{parentName:"p"},"getString()")," function, we passed an empty String. This is the returned value in case there aren\u2019t ",(0,r.yg)("inlineCode",{parentName:"p"},"ssid")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"password")," keys saved on preferences."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 6.")," Close the Preferences."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"preferences.end();\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The Store/get Key:value Pair data complete procedure is shown below.")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'#include <Preferences.h>\n\nPreferences preferences;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  Serial.println();\n\n  // Open Preferences with my-app namespace. Each application module, library, etc\n  // has to use a namespace name to prevent key name collisions. We will open storage in\n  // RW-mode (second parameter has to be false).\n  // Note: Namespace name is limited to 15 chars.\n  preferences.begin("my-app", false);\n\n  // Remove all preferences under the opened namespace\n  //preferences.clear();\n\n  // Or remove the counter key only\n  //preferences.remove("counter");\n\n  // Get the counter value, if the key does not exist, return a default value of 0\n  // Note: Key name is limited to 15 chars.\n  unsigned int counter = preferences.getUInt("counter", 0);\n\n  // Increase counter by 1\n  counter++;\n\n  // Print the counter to Serial Monitor\n  Serial.printf("Current counter value: %u\\n", counter);\n\n  // Store the counter to the Preferences\n  preferences.putUInt("counter", counter);\n\n  // Close the Preferences\n  preferences.end();\n\n  // Wait 10 seconds\n  Serial.println("Restarting in 10 seconds...");\n  delay(10000);\n\n  // Restart ESP\n  ESP.restart();\n}\n\nvoid loop() {\n\n}\n')),(0,r.yg)("p",null,"Upload the code to your board and this is what you should get on the Serial Monitor:"),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:"600",src:"https://files.seeedstudio.com/wiki/xiaoesp32c3-permanently-data/1.png"})),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"The Store/get String data complete procedure is shown below.")),(0,r.yg)("p",null,"Save Network Credentials using ",(0,r.yg)("inlineCode",{parentName:"p"},"Preferences.h"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'#include <Preferences.h>\n\nPreferences preferences;\n\nconst char* ssid = "REPLACE_WITH_YOUR_SSID";\nconst char* password = "REPLACE_WITH_YOUR_PASSWORD";\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  Serial.println();\n\n  preferences.begin("credentials", false);\n  preferences.putString("ssid", ssid); \n  preferences.putString("password", password);\n\n  Serial.println("Network Credentials Saved using Preferences");\n\n  preferences.end();\n}\n\nvoid loop() {\n\n}\n')),(0,r.yg)("p",null,"Upload the code to your board and this is what you should get on the Serial Monitor:"),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:"600",src:"https://files.seeedstudio.com/wiki/xiaoesp32c3-permanently-data/2.png"})),(0,r.yg)("p",null,"Connect to Wi-Fi with Network Credentials Saved on Preferences."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'#include <Preferences.h>\n#include "WiFi.h"\n\nPreferences preferences;\n\nString ssid;\nString password;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(3000);\n  Serial.println();\n  \n  preferences.begin("credentials", false);\n \n  ssid = preferences.getString("ssid", ""); \n  password = preferences.getString("password", "");\n\n  if (ssid == "" || password == ""){\n    Serial.println("No values saved for ssid or password");\n  }\n  else {\n    // Connect to Wi-Fi\n    WiFi.mode(WIFI_STA);\n    WiFi.disconnect();\n    delay(100);\n    WiFi.begin(ssid.c_str(), password.c_str());\n    Serial.print("Connecting to WiFi ");\n    Serial.println(ssid);\n    Serial.println(password);\n    while (WiFi.status() != WL_CONNECTED) {\n      Serial.print(\'.\');\n      delay(1000);\n    }\n    Serial.println(WiFi.localIP());  \n  }\n}\n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n}\n')),(0,r.yg)("p",null,"Upload this code to your board after the previous one (to ensure that you have the credentials saved). If everything goes as expected, this is what you should get on your Serial Monitor."),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:"600",src:"https://files.seeedstudio.com/wiki/xiaoesp32c3-permanently-data/3.png"})),(0,r.yg)("h2",{id:"store-permanent-data-using-eeprom"},"Store Permanent Data using EEPROM"),(0,r.yg)("h3",{id:"what-is-eeprom"},"What is EEPROM?"),(0,r.yg)("p",null,"The EEPROM is an internal memory of the ESP32 microcontroller that allows to keep in memory data after restarting the board. When working with microcontrollers, it is interesting to keep data in memory especially when the card turns off whether it is wanted or not, as in the case of a loss of electrical power."),(0,r.yg)("p",null,"The ESP32 microcontroller has a Flash memory area that can be interfaced with like the EEPROM of an Arduino to keep data in memory even after the board is turned off."),(0,r.yg)("admonition",{title:"Attention",type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"An important thing to note is that EEPROM has a limited size and life span. The memory cells can be read as many times as necessary but the number of write cycles is limited to ",(0,r.yg)("strong",{parentName:"p"},"100,000"),". It is advisable to pay close attention to the size of the stored data and how often you want to update it. The EEPROM memory can store 512 values from 0 to 255 or 128 IP addresses or RFID tags.")),(0,r.yg)("p",null,"The microcontroller on the ESP32 has EEPROM (Electrically Erasable Programmable Read-Only Memory). This is a small space that can store byte variables. The variables stored in the EEPROM kept there, event when you reset or power off the ESP32. Simply, the EEPROM is permanent storage similar to a hard drive in computers."),(0,r.yg)("p",null,"The EEPROM can be read, erased and re-written electronically. In Arduino, you can read and write from the EEPROM easily using the EEPROM library."),(0,r.yg)("p",null,"Each EEPROM position can save one byte, which means you can only store 8-bit numbers, which includes integer values between 0 and 255."),(0,r.yg)("h3",{id:"available-eeprom-functions"},"Available EEPROM Functions"),(0,r.yg)("p",null,"To read and write from the ESP32 flash memory using Arduino IDE, we\u2019ll be using the EEPROM library. Using this library with the ESP32 is very similar to using it with the Arduino. So, if you\u2019ve used the Arduino EEPROM before, this is not much different."),(0,r.yg)("p",null,"So, we also recommend taking a look at our article about ",(0,r.yg)("a",{parentName:"p",href:"https://randomnerdtutorials.com/arduino-eeprom-explained-remember-last-led-state/"},"Arduino EEPROM"),"."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 1"),". Initialize the memory size"),(0,r.yg)("p",null,"Before using the function, we have to initialize the size of the memory with ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.begin()"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.begin(EEPROM_SIZE);\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 2"),". Write & Put"),(0,r.yg)("p",null,"To write data into the EEPROM, you use the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.write()")," function that takes in two arguments. The first one is the EEPROM location or address where you want to save the data, and the second is the value we want to save:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.write(address, value);\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.write()")," is equivalent to using ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.put()"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.put(address, value);\n")),(0,r.yg)("p",null,"For example, to write 9 on address 0, you\u2019ll have:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.write(0, 9);\n")),(0,r.yg)("admonition",{type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"If we want to store float data, we usually use the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.put()")," method instead of the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.write()")," method. If you want to store it using the write() method, then you need to use ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.writeFloat()"),".")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 3"),". Read & Get"),(0,r.yg)("p",null,"To read a byte from the EEPROM, you use the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.read()")," function. This function takes the address of the byte has an argument."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.read(address);\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.read()")," is equivalent to using ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.get()"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.get(address);\n")),(0,r.yg)("p",null,"For example, to read the byte stored previously in address 0.:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.read(0);\n")),(0,r.yg)("p",null,"This would return ",(0,r.yg)("strong",{parentName:"p"},"9"),", which is the value stored in that location."),(0,r.yg)("admonition",{type:"tip"},(0,r.yg)("p",{parentName:"admonition"},"If we want to get float data, we usually use the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.get()")," method instead of the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.read()")," method. If you want to get it using the read() method, then you need to use ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.readFloat()"),".")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Func 4"),". Update a value"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.update()")," function is particularly useful. It only writes on the EEPROM if the value written is different from the one already saved."),(0,r.yg)("p",null,"As the EEPROM has limited life expectancy due to limited write/erase cycles, using the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.update()")," function instead of the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.write()")," saves cycles."),(0,r.yg)("p",null,"You use the ",(0,r.yg)("inlineCode",{parentName:"p"},"EEPROM.update()")," function as follows:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.update(address, value);\n")),(0,r.yg)("p",null,"At the moment, we have 9 stored in the address 0. So, if we call:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.update(0, 9);\n")),(0,r.yg)("p",null,"It won\u2019t write on the EEPROM again, as the value currently saved is the same we want to write."),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"To learn more about EEPROM operation, you can read the ",(0,r.yg)("a",{parentName:"p",href:"https://docs.arduino.cc/learn/programming/eeprom-guide#eeprom-clear"},"official Arduino documentation"),".")),(0,r.yg)("h3",{id:"general-ways-to-use-the-eeprom"},"General ways to use the EEPROM"),(0,r.yg)("p",null,"To show you how to save data in the XIAO ESP32C3 flash memory, we\u2019ll save the last state of an output, in this case an LED."),(0,r.yg)("p",null,"Wire an LED to the XIAO ESP32C3 as shown in the following schematic diagram."),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:"400",src:"https://files.seeedstudio.com/wiki/XIAO_WiFi/connect-led-2.png"})),(0,r.yg)("p",null,"First, you need to include the EEPROM library."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"#include <EEPROM.h>\n")),(0,r.yg)("p",null,"Then, you define the EEPROM size. This is the number of bytes you\u2019ll want to access in the flash memory. In this case, we\u2019ll just save the LED state, so the EEPROM size is set to 1."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"#define EEPROM_SIZE 1\n")),(0,r.yg)("p",null,"We also define other variables that are required to make this sketch work."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"// constants won't change. They're used here to set pin numbers:\nconst int ledPin = D10;      // the number of the LED pin\n\n// Variables will change:\nint ledState = LOW;  // ledState used to set the LED\n\n// Generally, you should use \"unsigned long\" for variables that hold time\n// The value will quickly become too large for an int to store\nunsigned long previousMillis = 0;  // will store last time LED was updated\n\n// constants won't change:\nconst long interval = 10000;  // interval at which to blink (milliseconds)\n")),(0,r.yg)("p",null,"In the ",(0,r.yg)("inlineCode",{parentName:"p"},"setup()")," you initialize the EEPROM with the predefined size."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.begin(EEPROM_SIZE);\n")),(0,r.yg)("p",null,"To make sure your code initializes with the latest LED state, in the ",(0,r.yg)("inlineCode",{parentName:"p"},"setup()"),", you should read the last LED state from the flash memory. It is stored on address zero."),(0,r.yg)("p",null,"Then, you just need to turn the LED ON or OFF accordingly to the value read from the flash memory."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"digitalWrite (ledPin, ledState);\n")),(0,r.yg)("p",null,"In the ",(0,r.yg)("inlineCode",{parentName:"p"},"loop()")," function section, all we need to do is flip the state of the LED over a period of time."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'// check to see if it\'s time to blink the LED; that is, if the difference\n// between the current time and last time you blinked the LED is bigger than\n// the interval at which you want to blink the LED.\nunsigned long currentMillis = millis();\n\nif (currentMillis - previousMillis >= interval) {\n    // save the last time you blinked the LED\n    previousMillis = currentMillis;\n    Serial.println("State changed");\n    // if the LED is off turn it on and vice-versa:\n    if (ledState == LOW) {\n      ledState = HIGH;\n    } else {\n      ledState = LOW;\n    }\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(ledPin, ledState);\n}\n')),(0,r.yg)("p",null,"Next, we need to determine if the countdown has ended, flip the state of the LED after it has ended, and store it in flash memory."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.write(0, ledState);\n")),(0,r.yg)("p",null,"Finally, we use the EEPROM.commit() for the changes to take effect."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},"EEPROM.commit();\n")),(0,r.yg)("p",null,"The following is the completed procedure."),(0,r.yg)("admonition",{title:"Attention",type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"Please note that you ",(0,r.yg)("strong",{parentName:"p"},"should not")," run this example for a long time. In this example, we will write the EEPROM every ten seconds, and running this example for a long time will ",(0,r.yg)("strong",{parentName:"p"},"greatly reduce")," the life of the EEPROM.")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-c"},'// include library to read and write from flash memory\n#include <EEPROM.h>\n\n// define the number of bytes you want to access\n#define EEPROM_SIZE 1\n\n// constants won\'t change. They\'re used here to set pin numbers:\nconst int ledPin = D10;      // the number of the LED pin\n\n// Variables will change:\nint ledState = LOW;  // ledState used to set the LED\n\n// Generally, you should use "unsigned long" for variables that hold time\n// The value will quickly become too large for an int to store\nunsigned long previousMillis = 0;  // will store last time LED was updated\n\n// constants won\'t change:\nconst long interval = 10000;  // interval at which to blink (milliseconds)\n\nvoid setup() { \n  Serial.begin(115200);\n  \n  // initialize EEPROM with predefined size\n  EEPROM.begin(EEPROM_SIZE);\n\n  pinMode(ledPin, OUTPUT);\n\n  // read the last LED state from flash memory\n  ledState = EEPROM.read(0);\n  // set the LED to the last stored state\n  digitalWrite(ledPin, ledState);\n}\n\nvoid loop() {\n  // here is where you\'d put code that needs to be running all the time.\n\n  // check to see if it\'s time to blink the LED; that is, if the difference\n  // between the current time and last time you blinked the LED is bigger than\n  // the interval at which you want to blink the LED.\n  unsigned long currentMillis = millis();\n\n  if (currentMillis - previousMillis >= interval) {\n    // save the last time you blinked the LED\n    previousMillis = currentMillis;\n    Serial.println("State changed");\n    // if the LED is off turn it on and vice-versa:\n    if (ledState == LOW) {\n      ledState = HIGH;\n    } else {\n      ledState = LOW;\n    }\n    // save the LED state in flash memory\n    EEPROM.write(0, ledState);\n    EEPROM.commit();\n    Serial.println("State saved in flash memory");\n\n    // set the LED with the ledState of the variable:\n    digitalWrite(ledPin, ledState);\n  }\n}\n')),(0,r.yg)("p",null,"Upload the code to your board and this is what you should get on the Serial Monitor:"),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:"600",src:"https://files.seeedstudio.com/wiki/xiaoesp32c3-permanently-data/4.png"})),(0,r.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,r.yg)("p",null,"Thank you for choosing our products! We are here to provide you with different support to ensure that your experience with our products is as smooth as possible. We offer several communication channels to cater to different preferences and needs."),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://forum.seeedstudio.com/",class:"button_forum"}),(0,r.yg)("a",{href:"https://www.seeedstudio.com/contacts",class:"button_email"})),(0,r.yg)("div",{class:"button_tech_support_container"},(0,r.yg)("a",{href:"https://discord.gg/eWkprNDMU7",class:"button_discord"}),(0,r.yg)("a",{href:"https://github.com/Seeed-Studio/wiki-documents/discussions/69",class:"button_discussion"})))}p.isMDXComponent=!0}}]);