"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[84298],{15680:(e,t,n)=>{n.d(t,{xA:()=>g,yg:()=>y});var a=n(96540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},g=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),p=d(n),u=r,y=p["".concat(s,".").concat(u)]||p[u]||m[u]||i;return n?a.createElement(y,o(o({ref:t},g),{},{components:n})):a.createElement(y,o({ref:t},g))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},61178:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var a=n(58168),r=(n(96540),n(15680));const i={description:"Grove - Thermal Imaging Camera IR-Array MLX90641",title:"Grove - Thermal Imaging Camera IR-Array MLX90641",keywords:["Grove"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/Grove-Thermal-Imaging-Camera-IR-Array",last_update:{date:"1/3/2023",author:"jianjing Huang"}},o=void 0,l={unversionedId:"Sensor/Grove/Grove_Sensors/Temperature/Grove-Thermal-Imaging-Camera-IR-Array",id:"Sensor/Grove/Grove_Sensors/Temperature/Grove-Thermal-Imaging-Camera-IR-Array",title:"Grove - Thermal Imaging Camera IR-Array MLX90641",description:"Grove - Thermal Imaging Camera IR-Array MLX90641",source:"@site/docs/Sensor/Grove/Grove_Sensors/Temperature/Grove-Thermal-Imaging-Camera-IR-Array.md",sourceDirName:"Sensor/Grove/Grove_Sensors/Temperature",slug:"/Grove-Thermal-Imaging-Camera-IR-Array",permalink:"/Grove-Thermal-Imaging-Camera-IR-Array",draft:!1,editUrl:"https://github.com/Seeed-Studio/wiki-documents/blob/docusaurus-version/docs/Sensor/Grove/Grove_Sensors/Temperature/Grove-Thermal-Imaging-Camera-IR-Array.md",tags:[],version:"current",lastUpdatedBy:"jianjing Huang",lastUpdatedAt:1672704e3,formattedLastUpdatedAt:"Jan 3, 2023",frontMatter:{description:"Grove - Thermal Imaging Camera IR-Array MLX90641",title:"Grove - Thermal Imaging Camera IR-Array MLX90641",keywords:["Grove"],image:"https://files.seeedstudio.com/wiki/wiki-platform/S-tempor.png",slug:"/Grove-Thermal-Imaging-Camera-IR-Array",last_update:{date:"1/3/2023",author:"jianjing Huang"}},sidebar:"ProductSidebar",previous:{title:"Grove - High Temperature Sensor",permalink:"/Grove-High_Temperature_Sensor"},next:{title:"Grove - Digital Infrared Temperature Sensor",permalink:"/Grove-Digital_Infrared_Temperature_Sensor"}},s={},d=[{value:"Versions",id:"versions",level:2},{value:"Features",id:"features",level:2},{value:"Specification",id:"specification",level:2},{value:"Platforms Supported",id:"platforms-supported",level:2},{value:"Getting Started",id:"getting-started",level:2},{value:"Getting Started by Wio Terminal",id:"getting-started-by-wio-terminal",level:3},{value:"Hardware Connection",id:"hardware-connection",level:4},{value:"Outcome of Visualization Format",id:"outcome-of-visualization-format",level:4},{value:"Outcome of Visualization on Wio Terminal",id:"outcome-of-visualization-on-wio-terminal",level:4},{value:"Getting Started by Raspberry Pi",id:"getting-started-by-raspberry-pi",level:3},{value:"Hardware",id:"hardware",level:4},{value:"Hardware Connection",id:"hardware-connection-1",level:4},{value:"Software",id:"software",level:4},{value:"Resourse",id:"resourse",level:2},{value:"Tech Support &amp; Product Discussion",id:"tech-support--product-discussion",level:2},{value:"Upgradable to Industrial Sensors",id:"upgradable-to-industrial-sensors",level:2}],g={toc:d},p="wrapper";function m(e){let{components:t,...n}=e;return(0,r.yg)(p,(0,a.A)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/grove-thermal-imaging-camera_-ir-array-mlx90641-55-front.jpg"}),(0,r.yg)("figcaption",null,(0,r.yg)("b",null)," ",(0,r.yg)("i",null,"Grove - Thermal Imaging Camera / IR Array MLX90641"))),(0,r.yg)("p",null,"This IR thermal camera carries a 16x12 array of thermal sensors ",(0,r.yg)("strong",{parentName:"p"},"(MLX90641)")," and it can detect the temperature of objects from far away with a center area accuracy of \xb11\u2103 and average accuracy of \xb11.5\u2103. In order to obtain the thermal images easily, the I2C protocol is used to get the low-resolution images from the camera. The FOV (Field of View) of this camera is 110\xb0x75\xb0, and the temperature measurement range is -40\u2103 to 300\u2103. In order to obtain the thermal image easily, I2C protocol is used to get the low-resolution image from the camera."),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/90640.png"}),(0,r.yg)("figcaption",null,(0,r.yg)("b",null)," ",(0,r.yg)("i",null,"Grove - Thermal Imaging Camera / IR Array MLX90640"))),(0,r.yg)("p",null,"While Grove - Thermal Imaging Camera is a thermal sensor ",(0,r.yg)("strong",{parentName:"p"},"(MLX90640)")," , carrying a 32x24 array of thermal sensors, and it can detect the temperature of objects from feet away with the accuracy of \xb11.5\u2103 and can present dynamic thermal images and detect the surrounding temperature from -40\u2103~300\u2103. The camera with narrow-angle/wide-angle has an FOV(Field of View) of 55\xb0x35\xb0/110\xb0x75\xb0.In order to obtain the thermal image easily, I2C protocol is used to get the low-resolution image from the camera."),(0,r.yg)("h2",{id:"versions"},"Versions"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Version"),(0,r.yg)("th",{parentName:"tr",align:null},"Date of Released"),(0,r.yg)("th",{parentName:"tr",align:null},"Order"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Grove - Thermal Imaging Camera / IR Array ",(0,r.yg)("strong",{parentName:"td"},"MLX90641")," 110 degree ",(0,r.yg)("strong",{parentName:"td"},"[",(0,r.yg)("em",{parentName:"strong"},"New"),"]")),(0,r.yg)("td",{parentName:"tr",align:null},"03-June-2020"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-Thermal-Imaging-Camera-IR-Array-MLX90641-110-degree-p-4612.html"},"Buy it"))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Grove - Thermal Imaging Camera / IR Array ",(0,r.yg)("strong",{parentName:"td"},"MLX90640")," 110 degree"),(0,r.yg)("td",{parentName:"tr",align:null},"12-Nov-2019"),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-Thermal-Imaging-Camera-IR-Array-MLX90640-110-degree-p-4334.html"},"Buy it"))))),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"This wiki fits both types of the Thermal Imageing Camera IR Array MLX90641 and MLX90640.")),(0,r.yg)("h2",{id:"features"},"Features"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Compact size 16x12 pixel IR thermal sensor array (MLX90641)\uff0c32x24 array pixel IR thermal sensor array (MLX90640)"),(0,r.yg)("li",{parentName:"ul"},"High FOV (field-of-view) of 110\xb0x75\xb0 to capture more area"),(0,r.yg)("li",{parentName:"ul"},"Wide temperature measurement range (-40\u2103~300\u2103)"),(0,r.yg)("li",{parentName:"ul"},"I2C Grove interface for easy communication with an MCU"),(0,r.yg)("li",{parentName:"ul"},"Fully calibrated IR array for convenient setup")),(0,r.yg)("h2",{id:"specification"},"Specification"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Item"),(0,r.yg)("th",{parentName:"tr",align:null},"Grove - Thermal Imaging Camera - MLX90640"),(0,r.yg)("th",{parentName:"tr",align:null},"Grove - Thermal Imaging Camera - MLX90641"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Thermal sensor"),(0,r.yg)("td",{parentName:"tr",align:null},"32X24 array MLX90640"),(0,r.yg)("td",{parentName:"tr",align:null},"16x12 array MLX90641")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Operating Voltage"),(0,r.yg)("td",{parentName:"tr",align:null},"3.3V - 5V"),(0,r.yg)("td",{parentName:"tr",align:null},"3.3V - 5V")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Current consumption"),(0,r.yg)("td",{parentName:"tr",align:null},"~18mA"),(0,r.yg)("td",{parentName:"tr",align:null},"~18mA")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"FOV(Field of View)"),(0,r.yg)("td",{parentName:"tr",align:null},"110\xb0x75\xb0"),(0,r.yg)("td",{parentName:"tr",align:null},"110\xb0x75\xb0")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Temperature Measurement Range"),(0,r.yg)("td",{parentName:"tr",align:null},"-40\xb0C - 300\xb0C"),(0,r.yg)("td",{parentName:"tr",align:null},"-40\xb0C - 300\xb0C")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Temperature Resolution"),(0,r.yg)("td",{parentName:"tr",align:null},"\xb1 1.5\xb0C"),(0,r.yg)("td",{parentName:"tr",align:null},"\xb1 1.5\xb0C (\xb11\u2103 at center area)")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Refresh Rate"),(0,r.yg)("td",{parentName:"tr",align:null},"0.5Hz - 64Hz"),(0,r.yg)("td",{parentName:"tr",align:null},"0.5Hz - 64Hz")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"Interface"),(0,r.yg)("td",{parentName:"tr",align:null},"I2C Grove interface"),(0,r.yg)("td",{parentName:"tr",align:null},"I2C Grove interface")),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},"I2C Address"),(0,r.yg)("td",{parentName:"tr",align:null},"0x33"),(0,r.yg)("td",{parentName:"tr",align:null},"0x33")))),(0,r.yg)("h2",{id:"platforms-supported"},"Platforms Supported"),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Arduino"),(0,r.yg)("th",{parentName:"tr",align:null},"Raspberry Pi"),(0,r.yg)("th",{parentName:"tr",align:null}),(0,r.yg)("th",{parentName:"tr",align:null}),(0,r.yg)("th",{parentName:"tr",align:null}))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/arduino_logo.jpg"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/raspberry_pi_logo.jpg"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/bbg_logo_n.jpg"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/wio_logo_n.jpg"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/wiki_english/docs/images/linkit_logo_n.jpg"})))))),(0,r.yg)("h2",{id:"getting-started"},"Getting Started"),(0,r.yg)("h3",{id:"getting-started-by-wio-terminal"},"Getting Started by Wio Terminal"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Materials required")),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Wio Terminal"),(0,r.yg)("th",{parentName:"tr",align:null},"Grove - Thermal Imaging Camera / IR Array MLX90641 110 degree"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/wio.png"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/small.jpg"})))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Wio-Terminal-p-4509.html"},"Get one now")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-Thermal-Imaging-Camera-IR-Array-MLX90641-110-degree-p-4612.html"},"Get one now"))))),(0,r.yg)("h4",{id:"hardware-connection"},"Hardware Connection"),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/hardware-connection.jpg"})),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 1.")," Plug Grove - Thermal Imaging Camera to Wio Terminal via Grove cable and also connect Wio Terminal to PC through a USB cable."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 2.")," Download the ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/Seeed-Studio/Seeed_Arduino_MLX9064x/archive/master.zip"},"Library")," and copy the whole ",(0,r.yg)("strong",{parentName:"p"},"Seeed_Arduino_MLX9064x")," file and paste it into your Arduino IDE library file."),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"If it is your first time playing Wio Terminal and not sure which interface to plug on Wio Terminal, please refer to ",(0,r.yg)("strong",{parentName:"p"},(0,r.yg)("a",{parentName:"strong",href:"https://wiki.seeedstudio.com/Wio-Terminal-Getting-Started/"},"Get Started with Wio Terminal")),".")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 3.")," Copy the Software Code 1 below into your Arduino IDE and upload it for visualization format displayed via ",(0,r.yg)("strong",{parentName:"p"},"Serial Port.")),(0,r.yg)("h4",{id:"outcome-of-visualization-format"},"Outcome of Visualization Format"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Software Code 1")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},'/*\n    Output the temperature readings to all pixels to be read by a Processing visualizer\n*/\n\n#include <Wire.h>\n\n#define USE_MLX90641\n\n#ifndef USE_MLX90641\n    #include "MLX90640_API.h"\n#else\n    #include "MLX90641_API.h"\n#endif\n\n#include "MLX9064X_I2C_Driver.h"\n\n#if defined(ARDUINO_ARCH_AVR)\n    #define debug  Serial\n\n#elif defined(ARDUINO_ARCH_SAMD) ||  defined(ARDUINO_ARCH_SAM)\n    #define debug  Serial\n#else\n    #define debug  Serial\n#endif\n\n#ifdef USE_MLX90641\n    const byte MLX90641_address = 0x33; //Default 7-bit unshifted address of the MLX90641\n    #define TA_SHIFT 8 //Default shift for MLX90641 in open air\n\n    uint16_t eeMLX90641[832];\n    float MLX90641To[192];\n    uint16_t MLX90641Frame[242];\n    paramsMLX90641 MLX90641;\n    int errorno = 0;\n#else\n    const byte MLX90640_address = 0x33; //Default 7-bit unshifted address of the MLX90640\n\n    #define TA_SHIFT 8 //Default shift for MLX90640 in open air\n\n    float mlx90640To[768];\n    paramsMLX90640 mlx90640;\n#endif\nvoid setup() {\n    Wire.begin();\n    Wire.setClock(400000); //Increase I2C clock speed to 400kHz\n\n    debug.begin(115200); //Fast debug as possible\n\n    while (!debug); //Wait for user to open terminal\n    //debug.println("MLX90640 IR Array Example");\n\n\n#ifndef USE_MLX90641\n    if (isConnected() == false) {\n        debug.println("MLX9064x not detected at default I2C address. Please check wiring. Freezing.");\n        while (1);\n    }\n    //Get device parameters - We only have to do this once\n    int status;\n    uint16_t eeMLX90640[832];\n    status = MLX90640_DumpEE(MLX90640_address, eeMLX90640);\n    if (status != 0) {\n        debug.println("Failed to load system parameters");\n    }\n\n    status = MLX90640_ExtractParameters(eeMLX90640, &mlx90640);\n    if (status != 0) {\n        debug.println("Parameter extraction failed");\n    }\n\n    //Once params are extracted, we can release eeMLX90640 array\n\n    //MLX90640_SetRefreshRate(MLX90640_address, 0x02); //Set rate to 2Hz\n    MLX90640_SetRefreshRate(MLX90640_address, 0x03); //Set rate to 4Hz\n    //MLX90640_SetRefreshRate(MLX90640_address, 0x07); //Set rate to 64H\n#else\n    if (isConnected() == false) {\n        debug.println("MLX90641 not detected at default I2C address. Please check wiring. Freezing.");\n        while (1);\n    }\n    //Get device parameters - We only have to do this once\n    int status;\n    status = MLX90641_DumpEE(MLX90641_address, eeMLX90641);\n    errorno = status;//MLX90641_CheckEEPROMValid(eeMLX90641);//eeMLX90641[10] & 0x0040;//\n    \n    if (status != 0) {\n        debug.println("Failed to load system parameters");\n       while(1);\n    }\n\n    status = MLX90641_ExtractParameters(eeMLX90641, &MLX90641);\n    //errorno = status;\n    if (status != 0) {\n        debug.println("Parameter extraction failed");\n        while(1);\n    }\n\n    //Once params are extracted, we can release eeMLX90641 array\n\n    //MLX90641_SetRefreshRate(MLX90641_address, 0x02); //Set rate to 2Hz\n    MLX90641_SetRefreshRate(MLX90641_address, 0x03); //Set rate to 4Hz\n    //MLX90641_SetRefreshRate(MLX90641_address, 0x07); //Set rate to 64Hz    \n#endif \n\n}\n\nvoid loop() {\n#ifndef USE_MLX90641\n    long startTime = millis();\n    for (byte x = 0 ; x < 2 ; x++) {\n        uint16_t mlx90640Frame[834];\n        int status = MLX90640_GetFrameData(MLX90640_address, mlx90640Frame);\n\n        float vdd = MLX90640_GetVdd(mlx90640Frame, &mlx90640);\n        float Ta = MLX90640_GetTa(mlx90640Frame, &mlx90640);\n\n        float tr = Ta - TA_SHIFT; //Reflected temperature based on the sensor ambient temperature\n        float emissivity = 0.95;\n\n        MLX90640_CalculateTo(mlx90640Frame, &mlx90640, emissivity, tr, mlx90640To);\n    }\n    long stopTime = millis();\n\n    for (int x = 0 ; x < 768 ; x++) {\n        //if(x % 8 == 0) debug.println();\n        debug.print(mlx90640To[x], 2);\n        debug.print(",");\n    }\n    debug.println("");\n#else\n    long startTime = millis();\n    \n    for (byte x = 0 ; x < 2 ; x++) {\n        int status = MLX90641_GetFrameData(MLX90641_address, MLX90641Frame);\n\n        float vdd = MLX90641_GetVdd(MLX90641Frame, &MLX90641);\n        float Ta = MLX90641_GetTa(MLX90641Frame, &MLX90641);\n\n        float tr = Ta - TA_SHIFT; //Reflected temperature based on the sensor ambient temperature\n        float emissivity = 0.95;\n\n        MLX90641_CalculateTo(MLX90641Frame, &MLX90641, emissivity, tr, MLX90641To);\n    }\n    long stopTime = millis();\n   /*\n    debug.print("vdd=");\n    debug.print(vdd,2);\n    debug.print(",Ta=");\n    debug.print(Ta,2);\n   \n    debug.print(",errorno=");\n    debug.print(errorno,DEC);\n    \n    \n    for (int x = 0 ; x < 64 ; x++) {\n        debug.print(MLX90641Frame[x], HEX);\n        debug.print(",");\n    }\n    \n    delay(1000);\n    */\n    for (int x = 0 ; x < 192 ; x++) {\n        debug.print(MLX90641To[x], 2);\n        debug.print(",");\n    }\n    debug.println("");    \n#endif\n}\n\n//Returns true if the MLX90640 is detected on the I2C bus\nboolean isConnected() {\n#ifndef USE_MLX90641\n    Wire.beginTransmission((uint8_t)MLX90640_address);\n#else\n    Wire.beginTransmission((uint8_t)MLX90641_address);\n#endif\n    if (Wire.endTransmission() != 0) {\n        return (false);    //Sensor did not ACK\n    }\n    return (true);\n}\n')),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"Upload the software code 1 above into your Arduino IDE and open the ",(0,r.yg)("strong",{parentName:"p"},"Serial Port"),", you will see an outcome of visualization format as following:")),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/20200702112317.png"}),(0,r.yg)("figcaption",null,(0,r.yg)("b",null)," ",(0,r.yg)("i",null))),(0,r.yg)("h4",{id:"outcome-of-visualization-on-wio-terminal"},"Outcome of Visualization on Wio Terminal"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Step 4.")," Upload the Software Code 2 below into your Arduino IDE for visualization displayed on Wio Terminal."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Software Code 2")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C++"},'#include <Wire.h>\n#include "MLX90641_API.h"\n#include "MLX9064X_I2C_Driver.h"\n#include <TFT_eSPI.h>                // Include the graphics library (this includes the sprite functions)  \n\nconst byte MLX90641_address = 0x33; //Default 7-bit unshifted address of the MLX90641\n#define TA_SHIFT 12 //Default shift for MLX90641 in open air\n#define debug  Serial\nuint16_t eeMLX90641[832];\nfloat MLX90641To[192];\nuint16_t MLX90641Frame[242];\nparamsMLX90641 MLX90641;\nint errorno = 0;\n\nTFT_eSPI    tft = TFT_eSPI(); \nTFT_eSprite Display = TFT_eSprite(&tft);  // Create Sprite object "img" with pointer to "tft" object\n// the pointer is used by pushSprite() to push it onto the TFT\n\nunsigned long CurTime;\n \nuint16_t TheColor;\n// start with some initial colors\nuint16_t MinTemp = 25;\nuint16_t MaxTemp = 38;\n\n// variables for interpolated colors\nbyte red, green, blue;\n \n// variables for row/column interpolation\nbyte i, j, k, row, col, incr;\nfloat intPoint, val, a, b, c, d, ii;\nbyte aLow, aHigh;\n\n// size of a display "pixel"\nbyte BoxWidth = 3;\nbyte BoxHeight = 3;\n\nint x, y;\nchar buf[20];\n \n// variable to toggle the display grid\nint ShowGrid = -1;\n \n// array for the interpolated array\nfloat HDTemp[6400];\n\nvoid setup() {\n    Wire.begin();\n    Wire.setClock(2000000); //Increase I2C clock speed to 2M\n    debug.begin(115200); //Fast debug as possible\n    \n    // start the display and set the background to black\n\n    if (isConnected() == false) {\n        debug.println("MLX90641 not detected at default I2C address. Please check wiring. Freezing.");\n        while (1);\n    }\n    //Get device parameters - We only have to do this once\n    int status;\n    status = MLX90641_DumpEE(MLX90641_address, eeMLX90641);\n    errorno = status;//MLX90641_CheckEEPROMValid(eeMLX90641);//eeMLX90641[10] & 0x0040;//\n    \n    if (status != 0) {\n        debug.println("Failed to load system parameters");\n       while(1);\n    }\n\n    status = MLX90641_ExtractParameters(eeMLX90641, &MLX90641);\n    //errorno = status;\n    if (status != 0) {\n        debug.println("Parameter extraction failed");\n        while(1);\n    }\n\n    //Once params are extracted, we can release eeMLX90641 array\n    \n    MLX90641_SetRefreshRate(MLX90641_address, 0x05); //Set rate to 16Hz\n\n    tft.begin();\n    tft.setRotation(3);\n    tft.fillScreen(TFT_BLACK);\n    Display.createSprite(TFT_HEIGHT, TFT_WIDTH);\n    Display.fillSprite(TFT_BLACK); \n\n    // get the cutoff points for the color interpolation routines\n    // note this function called when the temp scale is changed\n    Getabcd();\n\n    // draw a legend with the scale that matches the sensors max and min\n    DrawLegend();    \n}\nvoid loop() {\n    // draw a large white border for the temperature area\n    Display.fillRect(10, 10, 220, 220, TFT_WHITE);\n    for (byte x = 0 ; x < 2 ; x++) {\n        int status = MLX90641_GetFrameData(MLX90641_address, MLX90641Frame);\n\n        float vdd = MLX90641_GetVdd(MLX90641Frame, &MLX90641);\n        float Ta = MLX90641_GetTa(MLX90641Frame, &MLX90641);\n\n        float tr = Ta - TA_SHIFT; //Reflected temperature based on the sensor ambient temperature\n        float emissivity = 0.95;\n\n        MLX90641_CalculateTo(MLX90641Frame, &MLX90641, emissivity, tr, MLX90641To);\n    }\n\n    interpolate_image(MLX90641To,12,16,HDTemp,80,80);\n\n    //display the 80 x 80 array\n    DisplayGradient();\n    \n    //Crosshair in the middle of the screen\n    Display.drawCircle(115, 115, 5, TFT_WHITE);\n    Display.drawFastVLine(115, 105, 20, TFT_WHITE);\n    Display.drawFastHLine(105, 115, 20, TFT_WHITE);\n    //Displaying the temp at the middle of the Screen\n     \n    //Push the Sprite to the screen\n    Display.pushSprite(0, 0);\n\n    tft.setRotation(3);\n    tft.setTextColor(TFT_WHITE);\n    tft.drawFloat(HDTemp[35 * 80 + 35], 2, 90, 20);        \n\n}\n//Returns true if the MLX90640 is detected on the I2C bus\nboolean isConnected() {\n    Wire.beginTransmission((uint8_t)MLX90641_address);\n    if (Wire.endTransmission() != 0) {\n        return (false);    //Sensor did not ACK\n    }\n    return (true);\n}\n// function to display the results\nvoid DisplayGradient() {\n \n  tft.setRotation(4);\n \n  // rip through 70 rows\n  for (row = 0; row < 70; row ++) {\n \n    // fast way to draw a non-flicker grid--just make every 10 MLX90641To 2x2 as opposed to 3x3\n    // drawing lines after the grid will just flicker too much\n    if (ShowGrid < 0) {\n      BoxWidth = 3;\n    }\n    else {\n      if ((row % 10 == 9) ) {\n        BoxWidth = 2;\n      }\n      else {\n        BoxWidth = 3;\n      }\n    }\n    // then rip through each 70 cols\n    for (col = 0; col < 70; col++) {\n \n      // fast way to draw a non-flicker grid--just make every 10 MLX90641To 2x2 as opposed to 3x3\n      if (ShowGrid < 0) {\n        BoxHeight = 3;\n      }\n      else {\n        if ( (col % 10 == 9)) {\n          BoxHeight = 2;\n        }\n        else {\n          BoxHeight = 3;\n        }\n      }\n      // finally we can draw each the 70 x 70 points, note the call to get interpolated color\n      Display.fillRect((row * 3) + 15, (col * 3) + 15, BoxWidth, BoxHeight, GetColor(HDTemp[row * 80 + col]));\n    }\n  }\n \n}\n// my fast yet effective color interpolation routine\nuint16_t GetColor(float val) {\n \n  /*\n    pass in value and figure out R G B\n    several published ways to do this I basically graphed R G B and developed simple linear equations\n    again a 5-6-5 color display will not need accurate temp to R G B color calculation\n \n    equations based on\n    http://web-tech.ga-usa.com/2012/05/creating-a-custom-hot-to-cold-temperature-color-gradient-for-use-with-rrdtool/index.html\n \n  */\n \n  red = constrain(255.0 / (c - b) * val - ((b * 255.0) / (c - b)), 0, 255);\n \n  if ((val > MinTemp) & (val < a)) {\n    green = constrain(255.0 / (a - MinTemp) * val - (255.0 * MinTemp) / (a - MinTemp), 0, 255);\n  }\n  else if ((val >= a) & (val <= c)) {\n    green = 255;\n  }\n  else if (val > c) {\n    green = constrain(255.0 / (c - d) * val - (d * 255.0) / (c - d), 0, 255);\n  }\n  else if ((val > d) | (val < a)) {\n    green = 0;\n  }\n \n  if (val <= b) {\n    blue = constrain(255.0 / (a - b) * val - (255.0 * b) / (a - b), 0, 255);\n  }\n  else if ((val > b) & (val <= d)) {\n    blue = 0;\n  }\n  else if (val > d) {\n    blue = constrain(240.0 / (MaxTemp - d) * val - (d * 240.0) / (MaxTemp - d), 0, 240);\n  }\n \n  // use the displays color mapping function to get 5-6-5 color palet (R=5 bits, G=6 bits, B-5 bits)\n  return Display.color565(red, green, blue);\n \n}\n \n// function to get the cutoff points in the temp vs RGB graph\nvoid Getabcd() {\n \n  a = MinTemp + (MaxTemp - MinTemp) * 0.2121;\n  b = MinTemp + (MaxTemp - MinTemp) * 0.3182;\n  c = MinTemp + (MaxTemp - MinTemp) * 0.4242;\n  d = MinTemp + (MaxTemp - MinTemp) * 0.8182;\n \n}\nfloat get_point(float *p, uint8_t rows, uint8_t cols, int8_t x, int8_t y)\n{\n    if (x < 0)\n    {\n        x = 0;\n    }\n    if (y < 0)\n    {\n        y = 0;\n    }\n    if (x >= cols)\n    {\n        x = cols - 1;\n    }\n    if (y >= rows)\n    {\n        y = rows - 1;\n    }\n    return p[y * cols + x];\n}\n\nvoid set_point(float *p, uint8_t rows, uint8_t cols, int8_t x, int8_t y, float f)\n{\n    if ((x < 0) || (x >= cols))\n    {\n        return;\n    }\n    if ((y < 0) || (y >= rows))\n    {\n        return;\n    }\n    p[y * cols + x] = f;\n}\n\n// src is a grid src_rows * src_cols\n// dest is a pre-allocated grid, dest_rows*dest_cols\nvoid interpolate_image(float *src, uint8_t src_rows, uint8_t src_cols,\n                       float *dest, uint8_t dest_rows, uint8_t dest_cols)\n{\n    float mu_x = (src_cols - 1.0) / (dest_cols - 1.0);\n    float mu_y = (src_rows - 1.0) / (dest_rows - 1.0);\n\n    float adj_2d[16]; // matrix for storing adjacents\n\n    for (uint8_t y_idx = 0; y_idx < dest_rows; y_idx++)\n    {\n        for (uint8_t x_idx = 0; x_idx < dest_cols; x_idx++)\n        {\n            float x = x_idx * mu_x;\n            float y = y_idx * mu_y;\n            get_adjacents_2d(src, adj_2d, src_rows, src_cols, x, y);\n\n            float frac_x = x - (int)x; // we only need the ~delta~ between the points\n            float frac_y = y - (int)y; // we only need the ~delta~ between the points\n            float out = bicubicInterpolate(adj_2d, frac_x, frac_y);\n            set_point(dest, dest_rows, dest_cols, x_idx, y_idx, out);\n        }\n    }\n}\n\n// p is a list of 4 points, 2 to the left, 2 to the right\nfloat cubicInterpolate(float p[], float x)\n{\n    float r = p[1] + (0.5 * x * (p[2] - p[0] + x * (2.0 * p[0] - 5.0 * p[1] + 4.0 * p[2] - p[3] + x * (3.0 * (p[1] - p[2]) + p[3] - p[0]))));\n    return r;\n}\n\n// p is a 16-point 4x4 array of the 2 rows & columns left/right/above/below\nfloat bicubicInterpolate(float p[], float x, float y)\n{\n    float arr[4] = {0, 0, 0, 0};\n    arr[0] = cubicInterpolate(p + 0, x);\n    arr[1] = cubicInterpolate(p + 4, x);\n    arr[2] = cubicInterpolate(p + 8, x);\n    arr[3] = cubicInterpolate(p + 12, x);\n    return cubicInterpolate(arr, y);\n}\n\n// src is rows*cols and dest is a 4-point array passed in already allocated!\nvoid get_adjacents_1d(float *src, float *dest, uint8_t rows, uint8_t cols, int8_t x, int8_t y)\n{\n    // pick two items to the left\n    dest[0] = get_point(src, rows, cols, x - 1, y);\n    dest[1] = get_point(src, rows, cols, x, y);\n    // pick two items to the right\n    dest[2] = get_point(src, rows, cols, x + 1, y);\n    dest[3] = get_point(src, rows, cols, x + 2, y);\n}\n\n// src is rows*cols and dest is a 16-point array passed in already allocated!\nvoid get_adjacents_2d(float *src, float *dest, uint8_t rows, uint8_t cols, int8_t x, int8_t y)\n{\n    float arr[4];\n    for (int8_t delta_y = -1; delta_y < 3; delta_y++)\n    {                                          // -1, 0, 1, 2\n        float *row = dest + 4 * (delta_y + 1); // index into each chunk of 4\n        for (int8_t delta_x = -1; delta_x < 3; delta_x++)\n        { // -1, 0, 1, 2\n            row[delta_x + 1] = get_point(src, rows, cols, x + delta_x, y + delta_y);\n        }\n    }\n}\n\n// function to draw a legend\nvoid DrawLegend() {\n \n  //color legend with max and min text\n  j = 0;\n \n  float inc = (MaxTemp - MinTemp ) / 160.0;\n \n  for (ii = MinTemp; ii < MaxTemp; ii += inc) {\n    tft.drawFastHLine(260, 200 - j++, 30, GetColor(ii));\n  }\n \n  tft.setTextSize(2);\n  tft.setCursor(245, 20);\n  tft.setTextColor(TFT_WHITE, TFT_BLACK);\n  sprintf(buf, "%2d/%2d", MaxTemp, (int) (MaxTemp * 1.12) + 32);\n  tft.print(buf);\n \n  tft.setTextSize(2);\n  tft.setCursor(245, 210);\n  tft.setTextColor(TFT_WHITE, TFT_BLACK);\n  sprintf(buf, "%2d/%2d", MinTemp, (int) (MinTemp * 1.12) + 32);\n  tft.print(buf);\n \n}\n')),(0,r.yg)("admonition",{title:"success",type:"tip"},(0,r.yg)("p",{parentName:"admonition"}," The outcome of visualization will display on the screen of Wio Terminal if everything goes well")),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/thermal-sensor-90641.gif"}),(0,r.yg)("figcaption",null,(0,r.yg)("b",null)," ",(0,r.yg)("i",null))),(0,r.yg)("h3",{id:"getting-started-by-raspberry-pi"},"Getting Started by Raspberry Pi"),(0,r.yg)("h4",{id:"hardware"},"Hardware"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Materials required")),(0,r.yg)("table",null,(0,r.yg)("thead",{parentName:"table"},(0,r.yg)("tr",{parentName:"thead"},(0,r.yg)("th",{parentName:"tr",align:null},"Raspberry Pi 4"),(0,r.yg)("th",{parentName:"tr",align:null},"Grove Base Hat for Raspberry Pi"),(0,r.yg)("th",{parentName:"tr",align:null},"Grove - Thermal Imaging Camera / IR Array MLX90641 110 degree"))),(0,r.yg)("tbody",{parentName:"table"},(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/IR-thermal-imaging-sensor-MLX90640-/raspberry-pi-preview_2.jpg"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/IR-thermal-imaging-sensor-MLX90640-/httpsstatics3.jpg"}))),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/small.jpg"})))),(0,r.yg)("tr",{parentName:"tbody"},(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Raspberry-Pi-4-Computer-Model-B-4GB-p-4077.html"},"Get one now")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-Base-Hat-for-Raspberry-Pi.html"},"Get one now")),(0,r.yg)("td",{parentName:"tr",align:null},(0,r.yg)("a",{parentName:"td",href:"https://www.seeedstudio.com/Grove-Thermal-Imaging-Camera-IR-Array-MLX90640-110-degree-p-4334.html"},"Get one now"))))),(0,r.yg)("h4",{id:"hardware-connection-1"},"Hardware Connection"),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/ras_hardware-connection.jpg"})),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 1")," Connect the Grove - Thermal Imaging Camera to one of the two I2C ports."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 2")," Plug the Raspberry Pi 4 into Grove Base Hat for Raspberry Pi."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 3")," Connect the Raspberry Pi to a display via HDMI cable, and power on the Raspberry Pi 4 by USB type-C.")),(0,r.yg)("h4",{id:"software"},"Software"),(0,r.yg)("p",null,"Raspberry Pi 4 supports Python, so the project demo can be easily displayed from the Raspberry Pi 4 display if you follow the below steps."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 1")," Install ",(0,r.yg)("a",{parentName:"li",href:"https://github.com/Seeed-Studio/grove.py"},"grove.py")," by the command")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"pip3 install Seeed-grove.py\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 2")," Install the MLX90641 driver with the following command.\nPython environment(If you don't have authority of your Raspberry Pi):")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"pip3 install seeed-python-mlx9064x\n")),(0,r.yg)("p",null,"Upgrade to the latest driver:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"pip3 install --upgrade seeed-python-mlx9064x\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 3")," Check the corresponding i2c number of the Raspberry Pi:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"ls /dev/i2c*\n")),(0,r.yg)("p",null,"You may get the result like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"/dev/i2c-1\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 4")," Download the ",(0,r.yg)("a",{parentName:"p",href:"https://github.com/Seeed-Studio/Seeed_Python_MLX9064x.git"},"MLX90641 Library")," by ",(0,r.yg)("strong",{parentName:"p"},"git clone")," with command.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Step 5")," Run the ",(0,r.yg)("strong",{parentName:"p"},"BasicReadings.py")," file by the following commands:"))),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{width:1e3,src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/90641-raspi.png"})),(0,r.yg)("admonition",{title:"success",type:"tip"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"}," The outcome will be displayed as above if everything goes well.\n"))),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"}," An upgrated UI of outcome on Raspberry Pi has been released as following:\n"))),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 1")," Install pyqt5:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"sudo apt-get install python3-pyqt5 -y\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 2")," Installing from PyPI:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"sudo pip3 install seeed_python_ircamera\n")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 3")," Set the max i2c speed then reboot:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},'sudo sh -c "echo dtparam=i2c_arm=on,i2c_arm_baudrate=400000 >> /boot/config.txt"\nsudo reboot\n')),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Step 4")," Input below command in terminal:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"sudo ircamera I2C MLX90641\n")),(0,r.yg)("admonition",{title:"success",type:"tip"},(0,r.yg)("pre",{parentName:"admonition"},(0,r.yg)("code",{parentName:"pre"}," The outcome will be displayed as following if everything goes well.\n"))),(0,r.yg)("div",{align:"center"},(0,r.yg)("img",{src:"https://files.seeedstudio.com/wiki/Grove-Thermal-Imaging-Camera-IR-Array/img/outcome_UI.png"}),(0,r.yg)("figcaption",null,(0,r.yg)("b",null)," ",(0,r.yg)("i",null))),(0,r.yg)("h2",{id:"resourse"},"Resourse"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"[PDF]")," ",(0,r.yg)("a",{parentName:"li",href:"https://files.seeedstudio.com/products/101020892/res/MLX90641-Datasheet-Melexis.pdf"},"Datasheet of MLX90641")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"[ZIP]")," ",(0,r.yg)("a",{parentName:"li",href:"https://files.seeedstudio.com/products/101020892/res/Visualization-mlx90641.zip"},"MLX90641 Visualization"))),(0,r.yg)("h2",{id:"tech-support--product-discussion"},"Tech Support & Product Discussion"),(0,r.yg)("p",null,"Please submit any technical issue into our ",(0,r.yg)("a",{parentName:"p",href:"http://forum.seeedstudio.com/"},"forum"),"."),(0,r.yg)("h2",{id:"upgradable-to-industrial-sensors"},"Upgradable to Industrial Sensors"),(0,r.yg)("p",null,"With the SenseCAP ",(0,r.yg)("a",{parentName:"p",href:"https://www.seeedstudio.com/SenseCAP-XIAO-LoRaWAN-Controller-p-5474.html"},"S2110 controller")," and ",(0,r.yg)("a",{parentName:"p",href:"https://www.seeedstudio.com/SenseCAP-S2100-LoRaWAN-Data-Logger-p-5361.html"},"S2100 data logger"),", you can easily turn the Grove into a LoRaWAN\xae sensor. Seeed not only helps you with prototyping but also offers you the possibility to expand your project with the SenseCAP series of robust ",(0,r.yg)("a",{parentName:"p",href:"https://www.seeedstudio.com/catalogsearch/result/?q=sensecap&categories=SenseCAP&application=Temperature%2FHumidity~Soil~Gas~Light~Weather~Water~Automation~Positioning~Machine%20Learning~Voice%20Recognition&compatibility=SenseCAP"},"industrial sensors"),"."),(0,r.yg)("p",null,"The IP66 housing, Bluetooth configuration, compatibility with the global LoRaWAN\xae network, built-in 19 Ah battery, and powerful support from APP make the ",(0,r.yg)("a",{parentName:"p",href:"https://www.seeedstudio.com/catalogsearch/result/?q=S21&categories=SenseCAP&product_module=Device"},"SenseCAP S210x")," the best choice for industrial applications. The series includes sensors for soil moisture, air temperature and humidity, light intensity, CO2, EC, and an 8-in-1 weather station. Try the latest SenseCAP S210x for your next successful industrial project."),(0,r.yg)("div",{align:"center"},(0,r.yg)("a",{href:"https://www.seeedstudio.com/catalogsearch/result/?q=sensecap&application=Temperature%2FHumidity~Soil~Gas~Light~Weather~Water~Automation~Positioning~Machine%20Learning~Voice%20Recognition&compatibility=SenseCAP",target:"_blank"},(0,r.yg)("img",{width:"{800}",src:"https://files.seeedstudio.com/wiki/K1100_overview/sensecap.png"}))))}m.isMDXComponent=!0}}]);